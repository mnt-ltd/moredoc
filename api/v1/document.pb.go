// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v1/document.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// 文档
type Document struct {
	Id              int64       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Title           string      `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Keywords        string      `protobuf:"bytes,3,opt,name=keywords,proto3" json:"keywords,omitempty"`
	Description     string      `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	UserId          int64       `protobuf:"varint,5,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Cover           string      `protobuf:"bytes,6,opt,name=cover,proto3" json:"cover,omitempty"`
	Width           int32       `protobuf:"varint,7,opt,name=width,proto3" json:"width,omitempty"`
	Height          int32       `protobuf:"varint,8,opt,name=height,proto3" json:"height,omitempty"`
	Preview         int32       `protobuf:"varint,9,opt,name=preview,proto3" json:"preview,omitempty"`
	Pages           int32       `protobuf:"varint,10,opt,name=pages,proto3" json:"pages,omitempty"`
	Uuid            string      `protobuf:"bytes,11,opt,name=uuid,proto3" json:"uuid,omitempty"`
	DownloadCount   int32       `protobuf:"varint,12,opt,name=download_count,json=downloadCount,proto3" json:"download_count,omitempty"`
	ViewCount       int32       `protobuf:"varint,13,opt,name=view_count,json=viewCount,proto3" json:"view_count,omitempty"`
	FavoriteCount   int32       `protobuf:"varint,14,opt,name=favorite_count,json=favoriteCount,proto3" json:"favorite_count,omitempty"`
	CommentCount    int32       `protobuf:"varint,15,opt,name=comment_count,json=commentCount,proto3" json:"comment_count,omitempty"`
	Score           int32       `protobuf:"varint,16,opt,name=score,proto3" json:"score,omitempty"`
	ScoreCount      int32       `protobuf:"varint,17,opt,name=score_count,json=scoreCount,proto3" json:"score_count,omitempty"`
	Price           int32       `protobuf:"varint,18,opt,name=price,proto3" json:"price,omitempty"`
	Size_           int64       `protobuf:"varint,19,opt,name=size,proto3" json:"size,omitempty"`
	Status          int32       `protobuf:"varint,20,opt,name=status,proto3" json:"status,omitempty"`
	CreatedAt       *time.Time  `protobuf:"bytes,21,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at,omitempty"`
	UpdatedAt       *time.Time  `protobuf:"bytes,22,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at,omitempty"`
	DeletedAt       *time.Time  `protobuf:"bytes,23,opt,name=deleted_at,json=deletedAt,proto3,stdtime" json:"deleted_at,omitempty"`
	RecommendAt     *time.Time  `protobuf:"bytes,29,opt,name=recommend_at,json=recommendAt,proto3,stdtime" json:"recommend_at,omitempty"`
	DeletedUserId   int64       `protobuf:"varint,24,opt,name=deleted_user_id,json=deletedUserId,proto3" json:"deleted_user_id,omitempty"`
	Username        string      `protobuf:"bytes,25,opt,name=username,proto3" json:"username,omitempty"`
	CategoryId      []int64     `protobuf:"varint,26,rep,packed,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
	DeletedUsername string      `protobuf:"bytes,27,opt,name=deleted_username,json=deletedUsername,proto3" json:"deleted_username,omitempty"`
	Ext             string      `protobuf:"bytes,28,opt,name=ext,proto3" json:"ext,omitempty"`
	Attachment      *Attachment `protobuf:"bytes,30,opt,name=attachment,proto3" json:"attachment,omitempty"`
	User            *User       `protobuf:"bytes,31,opt,name=user,proto3" json:"user,omitempty"`
	EnableGzip      bool        `protobuf:"varint,32,opt,name=enable_gzip,json=enableGzip,proto3" json:"enable_gzip,omitempty"`
	ConvertError    string      `protobuf:"bytes,33,opt,name=convert_error,json=convertError,proto3" json:"convert_error,omitempty"`
}

func (m *Document) Reset()         { *m = Document{} }
func (m *Document) String() string { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()    {}
func (*Document) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{0}
}
func (m *Document) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Document) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Document.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Document) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Document.Merge(m, src)
}
func (m *Document) XXX_Size() int {
	return m.Size()
}
func (m *Document) XXX_DiscardUnknown() {
	xxx_messageInfo_Document.DiscardUnknown(m)
}

var xxx_messageInfo_Document proto.InternalMessageInfo

func (m *Document) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Document) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Document) GetKeywords() string {
	if m != nil {
		return m.Keywords
	}
	return ""
}

func (m *Document) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Document) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Document) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *Document) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Document) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Document) GetPreview() int32 {
	if m != nil {
		return m.Preview
	}
	return 0
}

func (m *Document) GetPages() int32 {
	if m != nil {
		return m.Pages
	}
	return 0
}

func (m *Document) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Document) GetDownloadCount() int32 {
	if m != nil {
		return m.DownloadCount
	}
	return 0
}

func (m *Document) GetViewCount() int32 {
	if m != nil {
		return m.ViewCount
	}
	return 0
}

func (m *Document) GetFavoriteCount() int32 {
	if m != nil {
		return m.FavoriteCount
	}
	return 0
}

func (m *Document) GetCommentCount() int32 {
	if m != nil {
		return m.CommentCount
	}
	return 0
}

func (m *Document) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Document) GetScoreCount() int32 {
	if m != nil {
		return m.ScoreCount
	}
	return 0
}

func (m *Document) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Document) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Document) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Document) GetCreatedAt() *time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Document) GetUpdatedAt() *time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *Document) GetDeletedAt() *time.Time {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *Document) GetRecommendAt() *time.Time {
	if m != nil {
		return m.RecommendAt
	}
	return nil
}

func (m *Document) GetDeletedUserId() int64 {
	if m != nil {
		return m.DeletedUserId
	}
	return 0
}

func (m *Document) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Document) GetCategoryId() []int64 {
	if m != nil {
		return m.CategoryId
	}
	return nil
}

func (m *Document) GetDeletedUsername() string {
	if m != nil {
		return m.DeletedUsername
	}
	return ""
}

func (m *Document) GetExt() string {
	if m != nil {
		return m.Ext
	}
	return ""
}

func (m *Document) GetAttachment() *Attachment {
	if m != nil {
		return m.Attachment
	}
	return nil
}

func (m *Document) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Document) GetEnableGzip() bool {
	if m != nil {
		return m.EnableGzip
	}
	return false
}

func (m *Document) GetConvertError() string {
	if m != nil {
		return m.ConvertError
	}
	return ""
}

// 删除文档，放入回收站
type DeleteDocumentRequest struct {
	Id []int64 `protobuf:"varint,1,rep,packed,name=id,proto3" json:"id,omitempty"`
}

func (m *DeleteDocumentRequest) Reset()         { *m = DeleteDocumentRequest{} }
func (m *DeleteDocumentRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteDocumentRequest) ProtoMessage()    {}
func (*DeleteDocumentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{1}
}
func (m *DeleteDocumentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteDocumentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteDocumentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteDocumentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteDocumentRequest.Merge(m, src)
}
func (m *DeleteDocumentRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteDocumentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteDocumentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteDocumentRequest proto.InternalMessageInfo

func (m *DeleteDocumentRequest) GetId() []int64 {
	if m != nil {
		return m.Id
	}
	return nil
}

// 恢复文档
type RecoverRecycleDocumentRequest struct {
	Id []int64 `protobuf:"varint,1,rep,packed,name=id,proto3" json:"id,omitempty"`
}

func (m *RecoverRecycleDocumentRequest) Reset()         { *m = RecoverRecycleDocumentRequest{} }
func (m *RecoverRecycleDocumentRequest) String() string { return proto.CompactTextString(m) }
func (*RecoverRecycleDocumentRequest) ProtoMessage()    {}
func (*RecoverRecycleDocumentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{2}
}
func (m *RecoverRecycleDocumentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoverRecycleDocumentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoverRecycleDocumentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoverRecycleDocumentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoverRecycleDocumentRequest.Merge(m, src)
}
func (m *RecoverRecycleDocumentRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecoverRecycleDocumentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoverRecycleDocumentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecoverRecycleDocumentRequest proto.InternalMessageInfo

func (m *RecoverRecycleDocumentRequest) GetId() []int64 {
	if m != nil {
		return m.Id
	}
	return nil
}

// 查询文档
type GetDocumentRequest struct {
	Id         int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	WithAuthor bool  `protobuf:"varint,2,opt,name=with_author,json=withAuthor,proto3" json:"with_author,omitempty"`
}

func (m *GetDocumentRequest) Reset()         { *m = GetDocumentRequest{} }
func (m *GetDocumentRequest) String() string { return proto.CompactTextString(m) }
func (*GetDocumentRequest) ProtoMessage()    {}
func (*GetDocumentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{3}
}
func (m *GetDocumentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDocumentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDocumentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDocumentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDocumentRequest.Merge(m, src)
}
func (m *GetDocumentRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetDocumentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDocumentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetDocumentRequest proto.InternalMessageInfo

func (m *GetDocumentRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GetDocumentRequest) GetWithAuthor() bool {
	if m != nil {
		return m.WithAuthor
	}
	return false
}

type SetDocumentsCategoryRequest struct {
	DocumentId []int64 `protobuf:"varint,1,rep,packed,name=document_id,json=documentId,proto3" json:"document_id,omitempty"`
	CategoryId []int64 `protobuf:"varint,2,rep,packed,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
}

func (m *SetDocumentsCategoryRequest) Reset()         { *m = SetDocumentsCategoryRequest{} }
func (m *SetDocumentsCategoryRequest) String() string { return proto.CompactTextString(m) }
func (*SetDocumentsCategoryRequest) ProtoMessage()    {}
func (*SetDocumentsCategoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{4}
}
func (m *SetDocumentsCategoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetDocumentsCategoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetDocumentsCategoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetDocumentsCategoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetDocumentsCategoryRequest.Merge(m, src)
}
func (m *SetDocumentsCategoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetDocumentsCategoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetDocumentsCategoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetDocumentsCategoryRequest proto.InternalMessageInfo

func (m *SetDocumentsCategoryRequest) GetDocumentId() []int64 {
	if m != nil {
		return m.DocumentId
	}
	return nil
}

func (m *SetDocumentsCategoryRequest) GetCategoryId() []int64 {
	if m != nil {
		return m.CategoryId
	}
	return nil
}

// 文档列表
type ListDocumentRequest struct {
	Page        int64    `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
	Size_       int64    `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Wd          string   `protobuf:"bytes,3,opt,name=wd,proto3" json:"wd,omitempty"`
	Field       []string `protobuf:"bytes,4,rep,name=field,proto3" json:"field,omitempty"`
	Order       string   `protobuf:"bytes,5,opt,name=order,proto3" json:"order,omitempty"`
	CategoryId  []int64  `protobuf:"varint,6,rep,packed,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
	UserId      []int64  `protobuf:"varint,7,rep,packed,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Status      []int32  `protobuf:"varint,8,rep,packed,name=status,proto3" json:"status,omitempty"`
	IsRecommend []bool   `protobuf:"varint,9,rep,packed,name=is_recommend,json=isRecommend,proto3" json:"is_recommend,omitempty"`
	Limit       int64    `protobuf:"varint,10,opt,name=limit,proto3" json:"limit,omitempty"`
	Ext         string   `protobuf:"bytes,11,opt,name=ext,proto3" json:"ext,omitempty"`
}

func (m *ListDocumentRequest) Reset()         { *m = ListDocumentRequest{} }
func (m *ListDocumentRequest) String() string { return proto.CompactTextString(m) }
func (*ListDocumentRequest) ProtoMessage()    {}
func (*ListDocumentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{5}
}
func (m *ListDocumentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDocumentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDocumentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDocumentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDocumentRequest.Merge(m, src)
}
func (m *ListDocumentRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListDocumentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDocumentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListDocumentRequest proto.InternalMessageInfo

func (m *ListDocumentRequest) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListDocumentRequest) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *ListDocumentRequest) GetWd() string {
	if m != nil {
		return m.Wd
	}
	return ""
}

func (m *ListDocumentRequest) GetField() []string {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *ListDocumentRequest) GetOrder() string {
	if m != nil {
		return m.Order
	}
	return ""
}

func (m *ListDocumentRequest) GetCategoryId() []int64 {
	if m != nil {
		return m.CategoryId
	}
	return nil
}

func (m *ListDocumentRequest) GetUserId() []int64 {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *ListDocumentRequest) GetStatus() []int32 {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ListDocumentRequest) GetIsRecommend() []bool {
	if m != nil {
		return m.IsRecommend
	}
	return nil
}

func (m *ListDocumentRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListDocumentRequest) GetExt() string {
	if m != nil {
		return m.Ext
	}
	return ""
}

// 文档列表
type ListDocumentReply struct {
	Total    int64       `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Document []*Document `protobuf:"bytes,2,rep,name=document,proto3" json:"document,omitempty"`
}

func (m *ListDocumentReply) Reset()         { *m = ListDocumentReply{} }
func (m *ListDocumentReply) String() string { return proto.CompactTextString(m) }
func (*ListDocumentReply) ProtoMessage()    {}
func (*ListDocumentReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{6}
}
func (m *ListDocumentReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDocumentReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDocumentReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDocumentReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDocumentReply.Merge(m, src)
}
func (m *ListDocumentReply) XXX_Size() int {
	return m.Size()
}
func (m *ListDocumentReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDocumentReply.DiscardUnknown(m)
}

var xxx_messageInfo_ListDocumentReply proto.InternalMessageInfo

func (m *ListDocumentReply) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ListDocumentReply) GetDocument() []*Document {
	if m != nil {
		return m.Document
	}
	return nil
}

// 创建文档
type CreateDocumentItem struct {
	Title        string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	AttachmentId int64  `protobuf:"varint,2,opt,name=attachment_id,json=attachmentId,proto3" json:"attachment_id,omitempty"`
	Price        int32  `protobuf:"varint,3,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *CreateDocumentItem) Reset()         { *m = CreateDocumentItem{} }
func (m *CreateDocumentItem) String() string { return proto.CompactTextString(m) }
func (*CreateDocumentItem) ProtoMessage()    {}
func (*CreateDocumentItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{7}
}
func (m *CreateDocumentItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDocumentItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDocumentItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDocumentItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDocumentItem.Merge(m, src)
}
func (m *CreateDocumentItem) XXX_Size() int {
	return m.Size()
}
func (m *CreateDocumentItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDocumentItem.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDocumentItem proto.InternalMessageInfo

func (m *CreateDocumentItem) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CreateDocumentItem) GetAttachmentId() int64 {
	if m != nil {
		return m.AttachmentId
	}
	return 0
}

func (m *CreateDocumentItem) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

// 创建文档
type CreateDocumentRequest struct {
	Overwrite  bool                  `protobuf:"varint,1,opt,name=overwrite,proto3" json:"overwrite,omitempty"`
	CategoryId []int64               `protobuf:"varint,2,rep,packed,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
	Document   []*CreateDocumentItem `protobuf:"bytes,3,rep,name=document,proto3" json:"document,omitempty"`
}

func (m *CreateDocumentRequest) Reset()         { *m = CreateDocumentRequest{} }
func (m *CreateDocumentRequest) String() string { return proto.CompactTextString(m) }
func (*CreateDocumentRequest) ProtoMessage()    {}
func (*CreateDocumentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{8}
}
func (m *CreateDocumentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDocumentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDocumentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDocumentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDocumentRequest.Merge(m, src)
}
func (m *CreateDocumentRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateDocumentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDocumentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDocumentRequest proto.InternalMessageInfo

func (m *CreateDocumentRequest) GetOverwrite() bool {
	if m != nil {
		return m.Overwrite
	}
	return false
}

func (m *CreateDocumentRequest) GetCategoryId() []int64 {
	if m != nil {
		return m.CategoryId
	}
	return nil
}

func (m *CreateDocumentRequest) GetDocument() []*CreateDocumentItem {
	if m != nil {
		return m.Document
	}
	return nil
}

// 设置文档推荐
type SetDocumentRecommendRequest struct {
	Id   []int64 `protobuf:"varint,1,rep,packed,name=id,proto3" json:"id,omitempty"`
	Type int32   `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *SetDocumentRecommendRequest) Reset()         { *m = SetDocumentRecommendRequest{} }
func (m *SetDocumentRecommendRequest) String() string { return proto.CompactTextString(m) }
func (*SetDocumentRecommendRequest) ProtoMessage()    {}
func (*SetDocumentRecommendRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{9}
}
func (m *SetDocumentRecommendRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetDocumentRecommendRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetDocumentRecommendRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetDocumentRecommendRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetDocumentRecommendRequest.Merge(m, src)
}
func (m *SetDocumentRecommendRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetDocumentRecommendRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetDocumentRecommendRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetDocumentRecommendRequest proto.InternalMessageInfo

func (m *SetDocumentRecommendRequest) GetId() []int64 {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SetDocumentRecommendRequest) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// 查询文档（针对首页的查询）
type ListDocumentForHomeRequest struct {
	Limit int64 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *ListDocumentForHomeRequest) Reset()         { *m = ListDocumentForHomeRequest{} }
func (m *ListDocumentForHomeRequest) String() string { return proto.CompactTextString(m) }
func (*ListDocumentForHomeRequest) ProtoMessage()    {}
func (*ListDocumentForHomeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{10}
}
func (m *ListDocumentForHomeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDocumentForHomeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDocumentForHomeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDocumentForHomeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDocumentForHomeRequest.Merge(m, src)
}
func (m *ListDocumentForHomeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListDocumentForHomeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDocumentForHomeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListDocumentForHomeRequest proto.InternalMessageInfo

func (m *ListDocumentForHomeRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// 首页文档查询返回项
type ListDocumentForHomeItem struct {
	CategoryId    int64       `protobuf:"varint,1,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
	CategoryCover string      `protobuf:"bytes,2,opt,name=category_cover,json=categoryCover,proto3" json:"category_cover,omitempty"`
	CategoryName  string      `protobuf:"bytes,3,opt,name=category_name,json=categoryName,proto3" json:"category_name,omitempty"`
	Document      []*Document `protobuf:"bytes,4,rep,name=document,proto3" json:"document,omitempty"`
}

func (m *ListDocumentForHomeItem) Reset()         { *m = ListDocumentForHomeItem{} }
func (m *ListDocumentForHomeItem) String() string { return proto.CompactTextString(m) }
func (*ListDocumentForHomeItem) ProtoMessage()    {}
func (*ListDocumentForHomeItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{11}
}
func (m *ListDocumentForHomeItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDocumentForHomeItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDocumentForHomeItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDocumentForHomeItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDocumentForHomeItem.Merge(m, src)
}
func (m *ListDocumentForHomeItem) XXX_Size() int {
	return m.Size()
}
func (m *ListDocumentForHomeItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDocumentForHomeItem.DiscardUnknown(m)
}

var xxx_messageInfo_ListDocumentForHomeItem proto.InternalMessageInfo

func (m *ListDocumentForHomeItem) GetCategoryId() int64 {
	if m != nil {
		return m.CategoryId
	}
	return 0
}

func (m *ListDocumentForHomeItem) GetCategoryCover() string {
	if m != nil {
		return m.CategoryCover
	}
	return ""
}

func (m *ListDocumentForHomeItem) GetCategoryName() string {
	if m != nil {
		return m.CategoryName
	}
	return ""
}

func (m *ListDocumentForHomeItem) GetDocument() []*Document {
	if m != nil {
		return m.Document
	}
	return nil
}

// 查询文档（针对首页的查询）
type ListDocumentForHomeResponse struct {
	Document []*ListDocumentForHomeItem `protobuf:"bytes,1,rep,name=document,proto3" json:"document,omitempty"`
}

func (m *ListDocumentForHomeResponse) Reset()         { *m = ListDocumentForHomeResponse{} }
func (m *ListDocumentForHomeResponse) String() string { return proto.CompactTextString(m) }
func (*ListDocumentForHomeResponse) ProtoMessage()    {}
func (*ListDocumentForHomeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{12}
}
func (m *ListDocumentForHomeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDocumentForHomeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDocumentForHomeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDocumentForHomeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDocumentForHomeResponse.Merge(m, src)
}
func (m *ListDocumentForHomeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListDocumentForHomeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDocumentForHomeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListDocumentForHomeResponse proto.InternalMessageInfo

func (m *ListDocumentForHomeResponse) GetDocument() []*ListDocumentForHomeItem {
	if m != nil {
		return m.Document
	}
	return nil
}

// 文档搜索
type SearchDocumentRequest struct {
	Page       int32   `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
	Size_      int32   `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Wd         string  `protobuf:"bytes,3,opt,name=wd,proto3" json:"wd,omitempty"`
	CategoryId []int64 `protobuf:"varint,4,rep,packed,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
	Sort       string  `protobuf:"bytes,5,opt,name=sort,proto3" json:"sort,omitempty"`
	Ext        string  `protobuf:"bytes,7,opt,name=ext,proto3" json:"ext,omitempty"`
}

func (m *SearchDocumentRequest) Reset()         { *m = SearchDocumentRequest{} }
func (m *SearchDocumentRequest) String() string { return proto.CompactTextString(m) }
func (*SearchDocumentRequest) ProtoMessage()    {}
func (*SearchDocumentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{13}
}
func (m *SearchDocumentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchDocumentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchDocumentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchDocumentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchDocumentRequest.Merge(m, src)
}
func (m *SearchDocumentRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchDocumentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchDocumentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchDocumentRequest proto.InternalMessageInfo

func (m *SearchDocumentRequest) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *SearchDocumentRequest) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchDocumentRequest) GetWd() string {
	if m != nil {
		return m.Wd
	}
	return ""
}

func (m *SearchDocumentRequest) GetCategoryId() []int64 {
	if m != nil {
		return m.CategoryId
	}
	return nil
}

func (m *SearchDocumentRequest) GetSort() string {
	if m != nil {
		return m.Sort
	}
	return ""
}

func (m *SearchDocumentRequest) GetExt() string {
	if m != nil {
		return m.Ext
	}
	return ""
}

// 文档评分
type DocumentScore struct {
	Id         int64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	DocumentId int64      `protobuf:"varint,2,opt,name=document_id,json=documentId,proto3" json:"document_id,omitempty"`
	UserId     int64      `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Score      int32      `protobuf:"varint,4,opt,name=score,proto3" json:"score,omitempty"`
	CreatedAt  *time.Time `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at,omitempty"`
	UpdatedAt  *time.Time `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at,omitempty"`
}

func (m *DocumentScore) Reset()         { *m = DocumentScore{} }
func (m *DocumentScore) String() string { return proto.CompactTextString(m) }
func (*DocumentScore) ProtoMessage()    {}
func (*DocumentScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{14}
}
func (m *DocumentScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentScore.Merge(m, src)
}
func (m *DocumentScore) XXX_Size() int {
	return m.Size()
}
func (m *DocumentScore) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentScore.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentScore proto.InternalMessageInfo

func (m *DocumentScore) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DocumentScore) GetDocumentId() int64 {
	if m != nil {
		return m.DocumentId
	}
	return 0
}

func (m *DocumentScore) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DocumentScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *DocumentScore) GetCreatedAt() *time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *DocumentScore) GetUpdatedAt() *time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

// 文档搜索响应
type SearchDocumentReply struct {
	Total    int64       `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Spend    string      `protobuf:"bytes,2,opt,name=spend,proto3" json:"spend,omitempty"`
	Document []*Document `protobuf:"bytes,3,rep,name=document,proto3" json:"document,omitempty"`
}

func (m *SearchDocumentReply) Reset()         { *m = SearchDocumentReply{} }
func (m *SearchDocumentReply) String() string { return proto.CompactTextString(m) }
func (*SearchDocumentReply) ProtoMessage()    {}
func (*SearchDocumentReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{15}
}
func (m *SearchDocumentReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchDocumentReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchDocumentReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchDocumentReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchDocumentReply.Merge(m, src)
}
func (m *SearchDocumentReply) XXX_Size() int {
	return m.Size()
}
func (m *SearchDocumentReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchDocumentReply.DiscardUnknown(m)
}

var xxx_messageInfo_SearchDocumentReply proto.InternalMessageInfo

func (m *SearchDocumentReply) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *SearchDocumentReply) GetSpend() string {
	if m != nil {
		return m.Spend
	}
	return ""
}

func (m *SearchDocumentReply) GetDocument() []*Document {
	if m != nil {
		return m.Document
	}
	return nil
}

// 文档下载
type DownloadDocumentReply struct {
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *DownloadDocumentReply) Reset()         { *m = DownloadDocumentReply{} }
func (m *DownloadDocumentReply) String() string { return proto.CompactTextString(m) }
func (*DownloadDocumentReply) ProtoMessage()    {}
func (*DownloadDocumentReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_55a584ae3a7fc022, []int{16}
}
func (m *DownloadDocumentReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadDocumentReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadDocumentReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadDocumentReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadDocumentReply.Merge(m, src)
}
func (m *DownloadDocumentReply) XXX_Size() int {
	return m.Size()
}
func (m *DownloadDocumentReply) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadDocumentReply.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadDocumentReply proto.InternalMessageInfo

func (m *DownloadDocumentReply) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func init() {
	proto.RegisterType((*Document)(nil), "api.v1.Document")
	proto.RegisterType((*DeleteDocumentRequest)(nil), "api.v1.DeleteDocumentRequest")
	proto.RegisterType((*RecoverRecycleDocumentRequest)(nil), "api.v1.RecoverRecycleDocumentRequest")
	proto.RegisterType((*GetDocumentRequest)(nil), "api.v1.GetDocumentRequest")
	proto.RegisterType((*SetDocumentsCategoryRequest)(nil), "api.v1.SetDocumentsCategoryRequest")
	proto.RegisterType((*ListDocumentRequest)(nil), "api.v1.ListDocumentRequest")
	proto.RegisterType((*ListDocumentReply)(nil), "api.v1.ListDocumentReply")
	proto.RegisterType((*CreateDocumentItem)(nil), "api.v1.CreateDocumentItem")
	proto.RegisterType((*CreateDocumentRequest)(nil), "api.v1.CreateDocumentRequest")
	proto.RegisterType((*SetDocumentRecommendRequest)(nil), "api.v1.SetDocumentRecommendRequest")
	proto.RegisterType((*ListDocumentForHomeRequest)(nil), "api.v1.ListDocumentForHomeRequest")
	proto.RegisterType((*ListDocumentForHomeItem)(nil), "api.v1.ListDocumentForHomeItem")
	proto.RegisterType((*ListDocumentForHomeResponse)(nil), "api.v1.ListDocumentForHomeResponse")
	proto.RegisterType((*SearchDocumentRequest)(nil), "api.v1.SearchDocumentRequest")
	proto.RegisterType((*DocumentScore)(nil), "api.v1.DocumentScore")
	proto.RegisterType((*SearchDocumentReply)(nil), "api.v1.SearchDocumentReply")
	proto.RegisterType((*DownloadDocumentReply)(nil), "api.v1.DownloadDocumentReply")
}

func init() { proto.RegisterFile("api/v1/document.proto", fileDescriptor_55a584ae3a7fc022) }

var fileDescriptor_55a584ae3a7fc022 = []byte{
	// 1690 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xc1, 0x6e, 0xe3, 0xc8,
	0x11, 0x1d, 0x8a, 0x92, 0x2d, 0x97, 0x64, 0x8d, 0xdc, 0xb6, 0x6c, 0x9a, 0xb2, 0x25, 0x0d, 0x1d,
	0x27, 0x5e, 0x23, 0xb0, 0x30, 0x0e, 0x92, 0xc3, 0xee, 0x21, 0xf0, 0x7a, 0x26, 0x8e, 0x81, 0x20,
	0x58, 0x70, 0x32, 0x58, 0x60, 0x2f, 0x0a, 0x47, 0x6c, 0x4b, 0x4c, 0x28, 0x91, 0x21, 0x5b, 0x56,
	0x6c, 0x24, 0x97, 0x7c, 0x40, 0xb0, 0x40, 0x80, 0xfd, 0x92, 0x7c, 0x44, 0x8e, 0x0b, 0x24, 0x87,
	0x00, 0x39, 0x64, 0x31, 0x93, 0x1f, 0xc8, 0x1f, 0x04, 0x5d, 0xdd, 0x4d, 0x51, 0x22, 0x69, 0x7b,
	0x37, 0xb7, 0xee, 0xea, 0xea, 0xf7, 0xba, 0xba, 0xab, 0x9e, 0x8a, 0x82, 0x96, 0x13, 0x7a, 0xfd,
	0xdb, 0x97, 0x7d, 0x37, 0x18, 0xce, 0x26, 0x74, 0xca, 0xce, 0xc2, 0x28, 0x60, 0x01, 0x59, 0x73,
	0x42, 0xef, 0xec, 0xf6, 0xa5, 0xd9, 0x1d, 0x05, 0xc1, 0xc8, 0xa7, 0x7d, 0xb4, 0xbe, 0x9b, 0xdd,
	0xf4, 0x99, 0x37, 0xa1, 0x31, 0x73, 0x26, 0xa1, 0x70, 0x34, 0x77, 0x46, 0xc1, 0x28, 0xc0, 0x61,
	0x9f, 0x8f, 0xa4, 0xf5, 0x40, 0x6e, 0xe3, 0xe0, 0xce, 0x74, 0x1a, 0x30, 0x87, 0x79, 0xc1, 0x34,
	0x96, 0xab, 0xed, 0x55, 0x50, 0x3a, 0x09, 0xd9, 0x9d, 0x5c, 0xdc, 0x93, 0x07, 0x72, 0x18, 0x73,
	0x86, 0xe3, 0xc5, 0x91, 0xcc, 0x2d, 0xb9, 0x30, 0x8b, 0x69, 0x24, 0x4c, 0xd6, 0x37, 0x55, 0xa8,
	0xbe, 0x92, 0x07, 0x27, 0x0d, 0x28, 0x79, 0xae, 0xa1, 0xf5, 0xb4, 0x13, 0xdd, 0x2e, 0x79, 0x2e,
	0xd9, 0x81, 0x0a, 0xf3, 0x98, 0x4f, 0x8d, 0x52, 0x4f, 0x3b, 0xd9, 0xb0, 0xc5, 0x84, 0x98, 0x50,
	0xfd, 0x2d, 0xbd, 0x9b, 0x07, 0x91, 0x1b, 0x1b, 0x3a, 0x2e, 0x24, 0x73, 0xd2, 0x83, 0x9a, 0x4b,
	0xe3, 0x61, 0xe4, 0x85, 0xfc, 0xb4, 0x46, 0x19, 0x97, 0xd3, 0x26, 0xb2, 0x07, 0xeb, 0x9c, 0x7e,
	0xe0, 0xb9, 0x46, 0x05, 0x89, 0xd6, 0xf8, 0xf4, 0x1a, 0xc9, 0x86, 0xc1, 0x2d, 0x8d, 0x8c, 0x35,
	0x41, 0x86, 0x13, 0x6e, 0x9d, 0x7b, 0x2e, 0x1b, 0x1b, 0xeb, 0x3d, 0xed, 0xa4, 0x62, 0x8b, 0x09,
	0xd9, 0x85, 0xb5, 0x31, 0xf5, 0x46, 0x63, 0x66, 0x54, 0xd1, 0x2c, 0x67, 0xc4, 0x80, 0xf5, 0x30,
	0xa2, 0xb7, 0x1e, 0x9d, 0x1b, 0x1b, 0xb8, 0xa0, 0xa6, 0x1c, 0x27, 0x74, 0x46, 0x34, 0x36, 0x40,
	0xe0, 0xe0, 0x84, 0x10, 0x28, 0xcf, 0x66, 0x9e, 0x6b, 0xd4, 0x90, 0x12, 0xc7, 0xe4, 0x18, 0x1a,
	0x6e, 0x30, 0x9f, 0xfa, 0x81, 0xe3, 0x0e, 0x86, 0xc1, 0x6c, 0xca, 0x8c, 0x3a, 0x6e, 0xd9, 0x54,
	0xd6, 0x4b, 0x6e, 0x24, 0x87, 0x00, 0x1c, 0x58, 0xba, 0x6c, 0xa2, 0xcb, 0x06, 0xb7, 0x88, 0xe5,
	0x63, 0x68, 0xdc, 0x38, 0xb7, 0x41, 0xe4, 0x31, 0x2a, 0x5d, 0x1a, 0x02, 0x45, 0x59, 0x85, 0xdb,
	0x11, 0x6c, 0x0e, 0x83, 0x09, 0xbf, 0x7c, 0xe9, 0xf5, 0x1c, 0xbd, 0xea, 0xd2, 0x28, 0x9c, 0x76,
	0xa0, 0x12, 0x0f, 0x83, 0x88, 0x1a, 0x4d, 0x71, 0x76, 0x9c, 0x90, 0x2e, 0xd4, 0x70, 0x20, 0x37,
	0x6e, 0xe1, 0x1a, 0xa0, 0x29, 0xd9, 0x16, 0x46, 0xde, 0x90, 0x1a, 0x44, 0x86, 0xcc, 0x27, 0x3c,
	0xe4, 0xd8, 0xbb, 0xa7, 0xc6, 0x36, 0x5e, 0x3e, 0x8e, 0xf9, 0x75, 0xc6, 0xcc, 0x61, 0xb3, 0xd8,
	0xd8, 0x11, 0xd7, 0x29, 0x66, 0xe4, 0xa7, 0x00, 0xc3, 0x88, 0x3a, 0x8c, 0xba, 0x03, 0x87, 0x19,
	0xad, 0x9e, 0x76, 0x52, 0x3b, 0x37, 0xcf, 0x44, 0xea, 0x9d, 0xa9, 0xd4, 0x3b, 0xfb, 0x95, 0xca,
	0xe7, 0x4f, 0xcb, 0x5f, 0xfe, 0xbb, 0xab, 0xd9, 0x1b, 0x72, 0xcf, 0x05, 0xe3, 0x00, 0xb3, 0xd0,
	0x55, 0x00, 0xbb, 0x4f, 0x05, 0x90, 0x7b, 0x04, 0x80, 0x4b, 0x7d, 0x2a, 0x01, 0xf6, 0x9e, 0x0a,
	0x20, 0xf7, 0x5c, 0x30, 0x72, 0x09, 0xf5, 0x88, 0x8a, 0xdb, 0x44, 0x88, 0xc3, 0x27, 0x42, 0xd4,
	0x92, 0x5d, 0x17, 0x8c, 0x7c, 0x1f, 0x9e, 0xab, 0x53, 0xa8, 0xdc, 0x35, 0xf0, 0xfa, 0x36, 0xa5,
	0xf9, 0xad, 0x48, 0x61, 0x13, 0xaa, 0x7c, 0x7d, 0xea, 0x4c, 0xa8, 0xb1, 0x2f, 0x2a, 0x43, 0xcd,
	0xf9, 0x73, 0x0d, 0x1d, 0x46, 0x47, 0x41, 0x74, 0xc7, 0xf7, 0x9b, 0x3d, 0xfd, 0x44, 0xb7, 0x41,
	0x99, 0xae, 0x5d, 0xf2, 0x11, 0x34, 0xd3, 0x24, 0x08, 0xd2, 0x46, 0x90, 0xe7, 0x29, 0x16, 0xc4,
	0x6a, 0x82, 0x4e, 0x7f, 0xcf, 0x8c, 0x03, 0x5c, 0xe5, 0x43, 0x72, 0x0e, 0xb0, 0xa8, 0x76, 0xa3,
	0x83, 0x41, 0x92, 0x33, 0xa1, 0x40, 0x67, 0x17, 0xc9, 0x8a, 0x9d, 0xf2, 0x22, 0x3d, 0x28, 0x73,
	0x22, 0xa3, 0x8b, 0xde, 0x75, 0xe5, 0xcd, 0x59, 0x6c, 0x5c, 0xe1, 0x67, 0xa6, 0x53, 0xe7, 0x9d,
	0x4f, 0x07, 0xa3, 0x7b, 0x2f, 0x34, 0x7a, 0x3d, 0xed, 0xa4, 0x6a, 0x83, 0x30, 0x5d, 0xdd, 0x7b,
	0xa1, 0x48, 0xdf, 0xe9, 0x2d, 0x8d, 0xd8, 0x80, 0x46, 0x51, 0x10, 0x19, 0x2f, 0xf0, 0x48, 0x75,
	0x69, 0x7c, 0xcd, 0x6d, 0xd6, 0x0f, 0xa0, 0xf5, 0x0a, 0x03, 0x50, 0x3a, 0x63, 0xd3, 0xdf, 0xcd,
	0x68, 0xbc, 0x90, 0x1b, 0x5d, 0xc8, 0x8d, 0xd5, 0x87, 0x43, 0x9b, 0x62, 0xd9, 0xdb, 0x74, 0x78,
	0x37, 0xf4, 0x1f, 0xdd, 0xf0, 0x1a, 0xc8, 0x15, 0x65, 0x45, 0x5e, 0x4a, 0xc5, 0xba, 0x50, 0x9b,
	0x7b, 0x6c, 0x3c, 0x70, 0x66, 0x6c, 0x1c, 0x44, 0xa8, 0x65, 0x55, 0x1b, 0xb8, 0xe9, 0x02, 0x2d,
	0xd6, 0x00, 0xda, 0x6f, 0x16, 0x30, 0xf1, 0xa5, 0x7c, 0x13, 0x85, 0xd7, 0x85, 0x9a, 0x92, 0xf6,
	0x41, 0x42, 0x0f, 0xca, 0x74, 0xed, 0xae, 0x3e, 0x6d, 0x69, 0xf5, 0x69, 0xad, 0xaf, 0x4a, 0xb0,
	0xfd, 0x0b, 0x2f, 0xce, 0x9c, 0x94, 0x40, 0x99, 0xeb, 0x90, 0x3c, 0x2b, 0x8e, 0x93, 0xfa, 0x2c,
	0xa5, 0xea, 0xb3, 0x01, 0xa5, 0xb9, 0x2b, 0xb5, 0xb6, 0x34, 0x47, 0xa9, 0xbc, 0xf1, 0xa8, 0xef,
	0x1a, 0xe5, 0x9e, 0xce, 0xa5, 0x12, 0x27, 0xdc, 0x1a, 0x44, 0x2e, 0x8d, 0x50, 0x57, 0x37, 0x6c,
	0x31, 0x59, 0x3d, 0xdc, 0x5a, 0x26, 0xef, 0x52, 0x82, 0xbc, 0x8e, 0x8b, 0x4a, 0x90, 0x17, 0xaa,
	0x50, 0xed, 0xe9, 0x29, 0x55, 0x78, 0x01, 0x75, 0x2f, 0x1e, 0x24, 0xf5, 0x61, 0x6c, 0xf4, 0xf4,
	0x93, 0xaa, 0x5d, 0xf3, 0x62, 0x5b, 0x99, 0xf8, 0x51, 0x7c, 0x6f, 0xe2, 0x31, 0x54, 0x5b, 0xdd,
	0x16, 0x13, 0x95, 0xb6, 0xb5, 0x24, 0x6d, 0xad, 0xcf, 0x61, 0x6b, 0xf9, 0x5e, 0x42, 0xff, 0x0e,
	0x7f, 0x75, 0x02, 0xe6, 0xf8, 0xf2, 0x5a, 0xc4, 0x84, 0xfc, 0x10, 0xaa, 0xea, 0xca, 0xf1, 0x86,
	0x6b, 0xe7, 0x4d, 0x95, 0xb1, 0xc9, 0xf6, 0xc4, 0xc3, 0xa2, 0x40, 0x2e, 0x51, 0x85, 0xd4, 0xda,
	0x35, 0xa3, 0x93, 0xc5, 0xef, 0x99, 0x96, 0xfe, 0x3d, 0x3b, 0x82, 0xcd, 0x45, 0x55, 0x88, 0x07,
	0xe4, 0xbc, 0xf5, 0x85, 0x51, 0xfc, 0x3a, 0x09, 0x31, 0xd5, 0x53, 0x62, 0x6a, 0xfd, 0x59, 0x83,
	0xd6, 0x32, 0x8f, 0x7a, 0xda, 0x03, 0xd8, 0xe0, 0x89, 0x3c, 0xe7, 0x52, 0x8f, 0x74, 0x55, 0x7b,
	0x61, 0x78, 0x34, 0x63, 0xc8, 0x4f, 0x52, 0xd1, 0xea, 0x18, 0xad, 0xa9, 0xa2, 0xcd, 0xc6, 0x95,
	0x8a, 0xfb, 0x62, 0x29, 0x95, 0x93, 0x07, 0x29, 0x28, 0x20, 0x9e, 0x6c, 0xec, 0x2e, 0x14, 0xc9,
	0x56, 0xb1, 0x71, 0x6c, 0x9d, 0x83, 0x99, 0x7e, 0x93, 0x9f, 0x05, 0xd1, 0xcf, 0x83, 0x09, 0x55,
	0x08, 0xc9, 0xcb, 0x6a, 0xa9, 0x97, 0xb5, 0xfe, 0xaa, 0xc1, 0x5e, 0xce, 0x26, 0xbc, 0xf4, 0x95,
	0x58, 0xc5, 0xbe, 0x74, 0xac, 0xc7, 0xd0, 0x48, 0x1c, 0x44, 0x07, 0x20, 0xda, 0x8d, 0x4d, 0x65,
	0xbd, 0xc4, 0x4e, 0x80, 0x6b, 0x8d, 0x72, 0x43, 0x71, 0xd4, 0xa5, 0xd6, 0x48, 0xe3, 0x2f, 0xb9,
	0x32, 0xa6, 0xb3, 0xa4, 0xfc, 0x68, 0x96, 0x7c, 0x01, 0xed, 0xdc, 0x50, 0xe3, 0x30, 0x98, 0xc6,
	0x94, 0x7c, 0x92, 0x02, 0xd3, 0x10, 0xac, 0xab, 0xc0, 0x0a, 0x82, 0x4d, 0x61, 0x7f, 0xa5, 0x41,
	0xeb, 0x0d, 0x75, 0xa2, 0xe1, 0xf8, 0xa1, 0xaa, 0xaf, 0xe4, 0x54, 0x7d, 0xa5, 0xa0, 0xea, 0x57,
	0x2e, 0xb2, 0x9c, 0x49, 0x1a, 0x0e, 0x12, 0x44, 0x4c, 0xd6, 0x3f, 0x8e, 0x55, 0xcd, 0xad, 0x2f,
	0x6a, 0xee, 0xbf, 0x1a, 0x6c, 0xaa, 0x23, 0xbd, 0xc1, 0x4e, 0x22, 0x47, 0x30, 0xd3, 0x82, 0x27,
	0xca, 0x21, 0x2d, 0x78, 0x29, 0xc9, 0xd0, 0x57, 0x7b, 0x38, 0xd1, 0xa9, 0x94, 0xd3, 0x9d, 0xca,
	0x72, 0x1b, 0x51, 0xf9, 0x7f, 0xdb, 0x88, 0xb5, 0x6f, 0xdd, 0x46, 0x58, 0x01, 0x6c, 0xaf, 0xbe,
	0x45, 0xb1, 0xd2, 0xf0, 0x20, 0x42, 0x2e, 0x6c, 0xb2, 0xeb, 0xc5, 0xc9, 0x52, 0x66, 0xe9, 0x8f,
	0x66, 0xd6, 0x47, 0xd0, 0x7a, 0x25, 0xdb, 0xc5, 0x65, 0xca, 0x26, 0xe8, 0xb3, 0xc8, 0x97, 0x02,
	0xc4, 0x87, 0xe7, 0xff, 0xa8, 0x41, 0x4d, 0xf9, 0x5c, 0x7c, 0x76, 0x4d, 0xfe, 0xb8, 0xfc, 0x5b,
	0x21, 0xb3, 0x8b, 0x58, 0x0f, 0xa4, 0x9e, 0xcc, 0x2c, 0xf3, 0xe8, 0x41, 0x1f, 0x91, 0xd5, 0xd6,
	0xe1, 0x9f, 0xfe, 0xfe, 0x9f, 0xbf, 0x94, 0xf6, 0x48, 0xab, 0xbf, 0xf2, 0xdd, 0xd2, 0x1f, 0x73,
	0x9e, 0x7b, 0xd8, 0xc9, 0x53, 0x10, 0x92, 0x60, 0x3f, 0xa0, 0x2f, 0xe6, 0x6e, 0xe6, 0x51, 0x5e,
	0xf3, 0xef, 0x12, 0xeb, 0x18, 0x39, 0xbb, 0xa6, 0x99, 0xe1, 0x4c, 0x7e, 0x46, 0x3e, 0xd6, 0x4e,
	0x89, 0x0b, 0x8d, 0x65, 0x75, 0x23, 0x87, 0xf9, 0xaa, 0xf7, 0x18, 0x5f, 0x1b, 0xf9, 0x5a, 0x56,
	0x73, 0x95, 0x8f, 0xb3, 0x7c, 0x0e, 0x8d, 0xb7, 0x98, 0x19, 0x09, 0x4b, 0xe6, 0x25, 0x1f, 0x03,
	0x36, 0x73, 0x81, 0x1d, 0x68, 0x2c, 0x37, 0x3a, 0x8b, 0xe3, 0xe7, 0x36, 0x40, 0x85, 0x2c, 0x06,
	0xb2, 0x90, 0xd3, 0x0c, 0x0b, 0x79, 0x0b, 0xb5, 0x54, 0xc7, 0x43, 0x92, 0x1f, 0x85, 0x6c, 0x1b,
	0x64, 0x66, 0x82, 0x52, 0xb0, 0x24, 0x0b, 0xeb, 0xc2, 0xf6, 0x15, 0x65, 0x36, 0xf5, 0x79, 0xbd,
	0x24, 0x8d, 0x50, 0xce, 0xbd, 0xec, 0xe7, 0x65, 0x18, 0x66, 0xb6, 0xd5, 0x43, 0x74, 0x93, 0x18,
	0x39, 0x6f, 0x8c, 0xb8, 0xe4, 0x06, 0x9a, 0xab, 0x45, 0x91, 0x43, 0xb1, 0xb8, 0xb3, 0xbc, 0x02,
	0xb2, 0x5e, 0x20, 0x4d, 0x9b, 0xec, 0x67, 0x68, 0xd4, 0xf7, 0x19, 0xa1, 0x50, 0x4f, 0x1f, 0x8f,
	0xb4, 0xf3, 0x0f, 0x2d, 0xae, 0xe9, 0x81, 0x88, 0x8a, 0x2b, 0xc5, 0xf7, 0x62, 0x46, 0x26, 0xd0,
	0x58, 0x16, 0x95, 0xc5, 0x73, 0xe7, 0x0a, 0xbf, 0xd9, 0x2e, 0x5a, 0xe6, 0x64, 0x5d, 0x24, 0xdb,
	0x27, 0x7b, 0x19, 0xb2, 0x18, 0xbd, 0x89, 0x0b, 0xcd, 0x54, 0xe9, 0x09, 0xe5, 0x6e, 0xad, 0xde,
	0x1e, 0x9a, 0x0b, 0xf3, 0x4a, 0xde, 0x9d, 0xb5, 0x9b, 0xe5, 0xe0, 0xfb, 0x78, 0x0e, 0xff, 0x1a,
	0x9a, 0x57, 0x4f, 0x64, 0xc9, 0x37, 0x5b, 0x1d, 0x24, 0x31, 0x48, 0x01, 0x09, 0xf9, 0x4d, 0x46,
	0x60, 0xf0, 0x5b, 0x81, 0x14, 0x1c, 0xba, 0x30, 0x18, 0x0b, 0x79, 0x0e, 0x0a, 0x34, 0x45, 0x60,
	0xde, 0x2d, 0x71, 0x25, 0x9d, 0x7d, 0xae, 0x98, 0xad, 0xf6, 0xfd, 0x85, 0xc4, 0xdf, 0x43, 0xe2,
	0x8e, 0x99, 0xcd, 0x40, 0xf5, 0x5b, 0xfc, 0xb1, 0x76, 0x7a, 0xfe, 0x2f, 0x1d, 0x40, 0x7e, 0xc6,
	0x70, 0x55, 0x0f, 0x84, 0xaa, 0xaf, 0x7c, 0xd8, 0x7c, 0xe7, 0xd4, 0x7c, 0xa8, 0xd8, 0x90, 0x81,
	0xfc, 0x01, 0x76, 0xf3, 0x3f, 0xa6, 0xc8, 0xb1, 0x82, 0x7d, 0xf0, 0x63, 0xab, 0x30, 0xfc, 0x23,
	0xa4, 0x3e, 0x34, 0x0b, 0xa9, 0x79, 0x1a, 0x85, 0xea, 0x9b, 0x6f, 0x95, 0xfc, 0x3b, 0x2a, 0xa2,
	0x8c, 0xf7, 0xb4, 0x38, 0x5e, 0x1f, 0x76, 0x2e, 0x7d, 0xea, 0x64, 0xa2, 0xfd, 0xb6, 0x69, 0x25,
	0x5f, 0xf7, 0xf4, 0xa0, 0x88, 0xa9, 0xef, 0xf8, 0xfe, 0xa7, 0x3f, 0xfe, 0xdb, 0xfb, 0x8e, 0xf6,
	0xf5, 0xfb, 0x8e, 0xf6, 0xcd, 0xfb, 0x8e, 0xf6, 0xe5, 0x87, 0xce, 0xb3, 0xaf, 0x3f, 0x74, 0x9e,
	0xfd, 0xf3, 0x43, 0xe7, 0x19, 0xc8, 0xbf, 0xfd, 0x3e, 0xd3, 0xbe, 0xd8, 0x9a, 0x04, 0x11, 0x75,
	0x83, 0xa1, 0x04, 0xfa, 0xe4, 0xf6, 0xe5, 0xbb, 0x35, 0x24, 0xfb, 0xd1, 0xff, 0x02, 0x00, 0x00,
	0xff, 0xff, 0xd6, 0x05, 0xf6, 0xca, 0x33, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DocumentAPIClient is the client API for DocumentAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DocumentAPIClient interface {
	// 针对首页的文档查询
	ListDocumentForHome(ctx context.Context, in *ListDocumentForHomeRequest, opts ...grpc.CallOption) (*ListDocumentForHomeResponse, error)
	// 设置文档推荐
	SetDocumentRecommend(ctx context.Context, in *SetDocumentRecommendRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 创建文档
	CreateDocument(ctx context.Context, in *CreateDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 更新文档
	UpdateDocument(ctx context.Context, in *Document, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 删除文档
	DeleteDocument(ctx context.Context, in *DeleteDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 查询文档
	GetDocument(ctx context.Context, in *GetDocumentRequest, opts ...grpc.CallOption) (*Document, error)
	// 根据文档ID查询当前文档的相关文档
	GetRelatedDocuments(ctx context.Context, in *Document, opts ...grpc.CallOption) (*ListDocumentReply, error)
	// 根据文档ID，获取文档下载链接
	DownloadDocument(ctx context.Context, in *Document, opts ...grpc.CallOption) (*DownloadDocumentReply, error)
	// 文档列表查询
	ListDocument(ctx context.Context, in *ListDocumentRequest, opts ...grpc.CallOption) (*ListDocumentReply, error)
	// 文档搜索
	SearchDocument(ctx context.Context, in *SearchDocumentRequest, opts ...grpc.CallOption) (*SearchDocumentReply, error)
	// 设置文档评分
	SetDocumentScore(ctx context.Context, in *DocumentScore, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 获取当前登录用户的文档评分
	GetDocumentScore(ctx context.Context, in *DocumentScore, opts ...grpc.CallOption) (*DocumentScore, error)
	// 将文档一键设置为重转
	SetDocumentReconvert(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 批量更新文档分类
	SetDocumentsCategory(ctx context.Context, in *SetDocumentsCategoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type documentAPIClient struct {
	cc *grpc.ClientConn
}

func NewDocumentAPIClient(cc *grpc.ClientConn) DocumentAPIClient {
	return &documentAPIClient{cc}
}

func (c *documentAPIClient) ListDocumentForHome(ctx context.Context, in *ListDocumentForHomeRequest, opts ...grpc.CallOption) (*ListDocumentForHomeResponse, error) {
	out := new(ListDocumentForHomeResponse)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/ListDocumentForHome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) SetDocumentRecommend(ctx context.Context, in *SetDocumentRecommendRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/SetDocumentRecommend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) CreateDocument(ctx context.Context, in *CreateDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/CreateDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) UpdateDocument(ctx context.Context, in *Document, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/UpdateDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) DeleteDocument(ctx context.Context, in *DeleteDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/DeleteDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) GetDocument(ctx context.Context, in *GetDocumentRequest, opts ...grpc.CallOption) (*Document, error) {
	out := new(Document)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/GetDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) GetRelatedDocuments(ctx context.Context, in *Document, opts ...grpc.CallOption) (*ListDocumentReply, error) {
	out := new(ListDocumentReply)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/GetRelatedDocuments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) DownloadDocument(ctx context.Context, in *Document, opts ...grpc.CallOption) (*DownloadDocumentReply, error) {
	out := new(DownloadDocumentReply)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/DownloadDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) ListDocument(ctx context.Context, in *ListDocumentRequest, opts ...grpc.CallOption) (*ListDocumentReply, error) {
	out := new(ListDocumentReply)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/ListDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) SearchDocument(ctx context.Context, in *SearchDocumentRequest, opts ...grpc.CallOption) (*SearchDocumentReply, error) {
	out := new(SearchDocumentReply)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/SearchDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) SetDocumentScore(ctx context.Context, in *DocumentScore, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/SetDocumentScore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) GetDocumentScore(ctx context.Context, in *DocumentScore, opts ...grpc.CallOption) (*DocumentScore, error) {
	out := new(DocumentScore)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/GetDocumentScore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) SetDocumentReconvert(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/SetDocumentReconvert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentAPIClient) SetDocumentsCategory(ctx context.Context, in *SetDocumentsCategoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.DocumentAPI/SetDocumentsCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DocumentAPIServer is the server API for DocumentAPI service.
type DocumentAPIServer interface {
	// 针对首页的文档查询
	ListDocumentForHome(context.Context, *ListDocumentForHomeRequest) (*ListDocumentForHomeResponse, error)
	// 设置文档推荐
	SetDocumentRecommend(context.Context, *SetDocumentRecommendRequest) (*emptypb.Empty, error)
	// 创建文档
	CreateDocument(context.Context, *CreateDocumentRequest) (*emptypb.Empty, error)
	// 更新文档
	UpdateDocument(context.Context, *Document) (*emptypb.Empty, error)
	// 删除文档
	DeleteDocument(context.Context, *DeleteDocumentRequest) (*emptypb.Empty, error)
	// 查询文档
	GetDocument(context.Context, *GetDocumentRequest) (*Document, error)
	// 根据文档ID查询当前文档的相关文档
	GetRelatedDocuments(context.Context, *Document) (*ListDocumentReply, error)
	// 根据文档ID，获取文档下载链接
	DownloadDocument(context.Context, *Document) (*DownloadDocumentReply, error)
	// 文档列表查询
	ListDocument(context.Context, *ListDocumentRequest) (*ListDocumentReply, error)
	// 文档搜索
	SearchDocument(context.Context, *SearchDocumentRequest) (*SearchDocumentReply, error)
	// 设置文档评分
	SetDocumentScore(context.Context, *DocumentScore) (*emptypb.Empty, error)
	// 获取当前登录用户的文档评分
	GetDocumentScore(context.Context, *DocumentScore) (*DocumentScore, error)
	// 将文档一键设置为重转
	SetDocumentReconvert(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// 批量更新文档分类
	SetDocumentsCategory(context.Context, *SetDocumentsCategoryRequest) (*emptypb.Empty, error)
}

// UnimplementedDocumentAPIServer can be embedded to have forward compatible implementations.
type UnimplementedDocumentAPIServer struct {
}

func (*UnimplementedDocumentAPIServer) ListDocumentForHome(ctx context.Context, req *ListDocumentForHomeRequest) (*ListDocumentForHomeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDocumentForHome not implemented")
}
func (*UnimplementedDocumentAPIServer) SetDocumentRecommend(ctx context.Context, req *SetDocumentRecommendRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDocumentRecommend not implemented")
}
func (*UnimplementedDocumentAPIServer) CreateDocument(ctx context.Context, req *CreateDocumentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDocument not implemented")
}
func (*UnimplementedDocumentAPIServer) UpdateDocument(ctx context.Context, req *Document) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDocument not implemented")
}
func (*UnimplementedDocumentAPIServer) DeleteDocument(ctx context.Context, req *DeleteDocumentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDocument not implemented")
}
func (*UnimplementedDocumentAPIServer) GetDocument(ctx context.Context, req *GetDocumentRequest) (*Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDocument not implemented")
}
func (*UnimplementedDocumentAPIServer) GetRelatedDocuments(ctx context.Context, req *Document) (*ListDocumentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRelatedDocuments not implemented")
}
func (*UnimplementedDocumentAPIServer) DownloadDocument(ctx context.Context, req *Document) (*DownloadDocumentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadDocument not implemented")
}
func (*UnimplementedDocumentAPIServer) ListDocument(ctx context.Context, req *ListDocumentRequest) (*ListDocumentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDocument not implemented")
}
func (*UnimplementedDocumentAPIServer) SearchDocument(ctx context.Context, req *SearchDocumentRequest) (*SearchDocumentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchDocument not implemented")
}
func (*UnimplementedDocumentAPIServer) SetDocumentScore(ctx context.Context, req *DocumentScore) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDocumentScore not implemented")
}
func (*UnimplementedDocumentAPIServer) GetDocumentScore(ctx context.Context, req *DocumentScore) (*DocumentScore, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDocumentScore not implemented")
}
func (*UnimplementedDocumentAPIServer) SetDocumentReconvert(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDocumentReconvert not implemented")
}
func (*UnimplementedDocumentAPIServer) SetDocumentsCategory(ctx context.Context, req *SetDocumentsCategoryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDocumentsCategory not implemented")
}

func RegisterDocumentAPIServer(s *grpc.Server, srv DocumentAPIServer) {
	s.RegisterService(&_DocumentAPI_serviceDesc, srv)
}

func _DocumentAPI_ListDocumentForHome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDocumentForHomeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).ListDocumentForHome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/ListDocumentForHome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).ListDocumentForHome(ctx, req.(*ListDocumentForHomeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_SetDocumentRecommend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDocumentRecommendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).SetDocumentRecommend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/SetDocumentRecommend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).SetDocumentRecommend(ctx, req.(*SetDocumentRecommendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_CreateDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).CreateDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/CreateDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).CreateDocument(ctx, req.(*CreateDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_UpdateDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Document)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).UpdateDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/UpdateDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).UpdateDocument(ctx, req.(*Document))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_DeleteDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).DeleteDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/DeleteDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).DeleteDocument(ctx, req.(*DeleteDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_GetDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).GetDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/GetDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).GetDocument(ctx, req.(*GetDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_GetRelatedDocuments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Document)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).GetRelatedDocuments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/GetRelatedDocuments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).GetRelatedDocuments(ctx, req.(*Document))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_DownloadDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Document)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).DownloadDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/DownloadDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).DownloadDocument(ctx, req.(*Document))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_ListDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).ListDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/ListDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).ListDocument(ctx, req.(*ListDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_SearchDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).SearchDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/SearchDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).SearchDocument(ctx, req.(*SearchDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_SetDocumentScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentScore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).SetDocumentScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/SetDocumentScore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).SetDocumentScore(ctx, req.(*DocumentScore))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_GetDocumentScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentScore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).GetDocumentScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/GetDocumentScore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).GetDocumentScore(ctx, req.(*DocumentScore))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_SetDocumentReconvert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).SetDocumentReconvert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/SetDocumentReconvert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).SetDocumentReconvert(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocumentAPI_SetDocumentsCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDocumentsCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentAPIServer).SetDocumentsCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.DocumentAPI/SetDocumentsCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentAPIServer).SetDocumentsCategory(ctx, req.(*SetDocumentsCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DocumentAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.DocumentAPI",
	HandlerType: (*DocumentAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListDocumentForHome",
			Handler:    _DocumentAPI_ListDocumentForHome_Handler,
		},
		{
			MethodName: "SetDocumentRecommend",
			Handler:    _DocumentAPI_SetDocumentRecommend_Handler,
		},
		{
			MethodName: "CreateDocument",
			Handler:    _DocumentAPI_CreateDocument_Handler,
		},
		{
			MethodName: "UpdateDocument",
			Handler:    _DocumentAPI_UpdateDocument_Handler,
		},
		{
			MethodName: "DeleteDocument",
			Handler:    _DocumentAPI_DeleteDocument_Handler,
		},
		{
			MethodName: "GetDocument",
			Handler:    _DocumentAPI_GetDocument_Handler,
		},
		{
			MethodName: "GetRelatedDocuments",
			Handler:    _DocumentAPI_GetRelatedDocuments_Handler,
		},
		{
			MethodName: "DownloadDocument",
			Handler:    _DocumentAPI_DownloadDocument_Handler,
		},
		{
			MethodName: "ListDocument",
			Handler:    _DocumentAPI_ListDocument_Handler,
		},
		{
			MethodName: "SearchDocument",
			Handler:    _DocumentAPI_SearchDocument_Handler,
		},
		{
			MethodName: "SetDocumentScore",
			Handler:    _DocumentAPI_SetDocumentScore_Handler,
		},
		{
			MethodName: "GetDocumentScore",
			Handler:    _DocumentAPI_GetDocumentScore_Handler,
		},
		{
			MethodName: "SetDocumentReconvert",
			Handler:    _DocumentAPI_SetDocumentReconvert_Handler,
		},
		{
			MethodName: "SetDocumentsCategory",
			Handler:    _DocumentAPI_SetDocumentsCategory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/document.proto",
}

// RecycleAPIClient is the client API for RecycleAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RecycleAPIClient interface {
	// 文档回收站列表
	ListRecycleDocument(ctx context.Context, in *ListDocumentRequest, opts ...grpc.CallOption) (*ListDocumentReply, error)
	// 恢复回收站文档，支持恢复单个文档或者是批量恢复
	RecoverRecycleDocument(ctx context.Context, in *RecoverRecycleDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 删除回收站文档
	DeleteRecycleDocument(ctx context.Context, in *DeleteDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 清空回收站文档
	ClearRecycleDocument(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type recycleAPIClient struct {
	cc *grpc.ClientConn
}

func NewRecycleAPIClient(cc *grpc.ClientConn) RecycleAPIClient {
	return &recycleAPIClient{cc}
}

func (c *recycleAPIClient) ListRecycleDocument(ctx context.Context, in *ListDocumentRequest, opts ...grpc.CallOption) (*ListDocumentReply, error) {
	out := new(ListDocumentReply)
	err := c.cc.Invoke(ctx, "/api.v1.RecycleAPI/ListRecycleDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *recycleAPIClient) RecoverRecycleDocument(ctx context.Context, in *RecoverRecycleDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.RecycleAPI/RecoverRecycleDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *recycleAPIClient) DeleteRecycleDocument(ctx context.Context, in *DeleteDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.RecycleAPI/DeleteRecycleDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *recycleAPIClient) ClearRecycleDocument(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.RecycleAPI/ClearRecycleDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RecycleAPIServer is the server API for RecycleAPI service.
type RecycleAPIServer interface {
	// 文档回收站列表
	ListRecycleDocument(context.Context, *ListDocumentRequest) (*ListDocumentReply, error)
	// 恢复回收站文档，支持恢复单个文档或者是批量恢复
	RecoverRecycleDocument(context.Context, *RecoverRecycleDocumentRequest) (*emptypb.Empty, error)
	// 删除回收站文档
	DeleteRecycleDocument(context.Context, *DeleteDocumentRequest) (*emptypb.Empty, error)
	// 清空回收站文档
	ClearRecycleDocument(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
}

// UnimplementedRecycleAPIServer can be embedded to have forward compatible implementations.
type UnimplementedRecycleAPIServer struct {
}

func (*UnimplementedRecycleAPIServer) ListRecycleDocument(ctx context.Context, req *ListDocumentRequest) (*ListDocumentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRecycleDocument not implemented")
}
func (*UnimplementedRecycleAPIServer) RecoverRecycleDocument(ctx context.Context, req *RecoverRecycleDocumentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverRecycleDocument not implemented")
}
func (*UnimplementedRecycleAPIServer) DeleteRecycleDocument(ctx context.Context, req *DeleteDocumentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRecycleDocument not implemented")
}
func (*UnimplementedRecycleAPIServer) ClearRecycleDocument(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearRecycleDocument not implemented")
}

func RegisterRecycleAPIServer(s *grpc.Server, srv RecycleAPIServer) {
	s.RegisterService(&_RecycleAPI_serviceDesc, srv)
}

func _RecycleAPI_ListRecycleDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecycleAPIServer).ListRecycleDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.RecycleAPI/ListRecycleDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecycleAPIServer).ListRecycleDocument(ctx, req.(*ListDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RecycleAPI_RecoverRecycleDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecoverRecycleDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecycleAPIServer).RecoverRecycleDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.RecycleAPI/RecoverRecycleDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecycleAPIServer).RecoverRecycleDocument(ctx, req.(*RecoverRecycleDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RecycleAPI_DeleteRecycleDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecycleAPIServer).DeleteRecycleDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.RecycleAPI/DeleteRecycleDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecycleAPIServer).DeleteRecycleDocument(ctx, req.(*DeleteDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RecycleAPI_ClearRecycleDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecycleAPIServer).ClearRecycleDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.RecycleAPI/ClearRecycleDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecycleAPIServer).ClearRecycleDocument(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _RecycleAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.RecycleAPI",
	HandlerType: (*RecycleAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListRecycleDocument",
			Handler:    _RecycleAPI_ListRecycleDocument_Handler,
		},
		{
			MethodName: "RecoverRecycleDocument",
			Handler:    _RecycleAPI_RecoverRecycleDocument_Handler,
		},
		{
			MethodName: "DeleteRecycleDocument",
			Handler:    _RecycleAPI_DeleteRecycleDocument_Handler,
		},
		{
			MethodName: "ClearRecycleDocument",
			Handler:    _RecycleAPI_ClearRecycleDocument_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/document.proto",
}

func (m *Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Document) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Document) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConvertError) > 0 {
		i -= len(m.ConvertError)
		copy(dAtA[i:], m.ConvertError)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.ConvertError)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.EnableGzip {
		i--
		if m.EnableGzip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDocument(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.Attachment != nil {
		{
			size, err := m.Attachment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDocument(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.RecommendAt != nil {
		n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.RecommendAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.RecommendAt):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintDocument(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if len(m.Ext) > 0 {
		i -= len(m.Ext)
		copy(dAtA[i:], m.Ext)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Ext)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.DeletedUsername) > 0 {
		i -= len(m.DeletedUsername)
		copy(dAtA[i:], m.DeletedUsername)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.DeletedUsername)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.CategoryId) > 0 {
		dAtA5 := make([]byte, len(m.CategoryId)*10)
		var j4 int
		for _, num1 := range m.CategoryId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintDocument(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.DeletedUserId != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.DeletedUserId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.DeletedAt != nil {
		n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.DeletedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.DeletedAt):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintDocument(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.UpdatedAt != nil {
		n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpdatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt):])
		if err7 != nil {
			return 0, err7
		}
		i -= n7
		i = encodeVarintDocument(dAtA, i, uint64(n7))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.CreatedAt != nil {
		n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CreatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintDocument(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Status != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Size_ != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Price != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ScoreCount != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.ScoreCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Score != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CommentCount != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.CommentCount))
		i--
		dAtA[i] = 0x78
	}
	if m.FavoriteCount != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.FavoriteCount))
		i--
		dAtA[i] = 0x70
	}
	if m.ViewCount != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.ViewCount))
		i--
		dAtA[i] = 0x68
	}
	if m.DownloadCount != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.DownloadCount))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Pages != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Pages))
		i--
		dAtA[i] = 0x50
	}
	if m.Preview != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Preview))
		i--
		dAtA[i] = 0x48
	}
	if m.Height != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x40
	}
	if m.Width != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Cover) > 0 {
		i -= len(m.Cover)
		copy(dAtA[i:], m.Cover)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Cover)))
		i--
		dAtA[i] = 0x32
	}
	if m.UserId != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Keywords) > 0 {
		i -= len(m.Keywords)
		copy(dAtA[i:], m.Keywords)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Keywords)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteDocumentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteDocumentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteDocumentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA10 := make([]byte, len(m.Id)*10)
		var j9 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintDocument(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecoverRecycleDocumentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoverRecycleDocumentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoverRecycleDocumentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA12 := make([]byte, len(m.Id)*10)
		var j11 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintDocument(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDocumentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDocumentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDocumentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithAuthor {
		i--
		if m.WithAuthor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetDocumentsCategoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDocumentsCategoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetDocumentsCategoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CategoryId) > 0 {
		dAtA14 := make([]byte, len(m.CategoryId)*10)
		var j13 int
		for _, num1 := range m.CategoryId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintDocument(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DocumentId) > 0 {
		dAtA16 := make([]byte, len(m.DocumentId)*10)
		var j15 int
		for _, num1 := range m.DocumentId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintDocument(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListDocumentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDocumentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDocumentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ext) > 0 {
		i -= len(m.Ext)
		copy(dAtA[i:], m.Ext)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Ext)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Limit != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x50
	}
	if len(m.IsRecommend) > 0 {
		for iNdEx := len(m.IsRecommend) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.IsRecommend[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintDocument(dAtA, i, uint64(len(m.IsRecommend)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Status) > 0 {
		dAtA18 := make([]byte, len(m.Status)*10)
		var j17 int
		for _, num1 := range m.Status {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintDocument(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x42
	}
	if len(m.UserId) > 0 {
		dAtA20 := make([]byte, len(m.UserId)*10)
		var j19 int
		for _, num1 := range m.UserId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintDocument(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CategoryId) > 0 {
		dAtA22 := make([]byte, len(m.CategoryId)*10)
		var j21 int
		for _, num1 := range m.CategoryId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintDocument(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Order) > 0 {
		i -= len(m.Order)
		copy(dAtA[i:], m.Order)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Order)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Field) > 0 {
		for iNdEx := len(m.Field) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Field[iNdEx])
			copy(dAtA[i:], m.Field[iNdEx])
			i = encodeVarintDocument(dAtA, i, uint64(len(m.Field[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Wd) > 0 {
		i -= len(m.Wd)
		copy(dAtA[i:], m.Wd)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Wd)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Size_ != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Page != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListDocumentReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDocumentReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDocumentReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Document) > 0 {
		for iNdEx := len(m.Document) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Document[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDocument(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Total != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateDocumentItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDocumentItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDocumentItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Price != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x18
	}
	if m.AttachmentId != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.AttachmentId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateDocumentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDocumentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDocumentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Document) > 0 {
		for iNdEx := len(m.Document) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Document[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDocument(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CategoryId) > 0 {
		dAtA24 := make([]byte, len(m.CategoryId)*10)
		var j23 int
		for _, num1 := range m.CategoryId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintDocument(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x12
	}
	if m.Overwrite {
		i--
		if m.Overwrite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetDocumentRecommendRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDocumentRecommendRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetDocumentRecommendRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		dAtA26 := make([]byte, len(m.Id)*10)
		var j25 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintDocument(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListDocumentForHomeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDocumentForHomeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDocumentForHomeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListDocumentForHomeItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDocumentForHomeItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDocumentForHomeItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Document) > 0 {
		for iNdEx := len(m.Document) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Document[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDocument(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CategoryName) > 0 {
		i -= len(m.CategoryName)
		copy(dAtA[i:], m.CategoryName)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.CategoryName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CategoryCover) > 0 {
		i -= len(m.CategoryCover)
		copy(dAtA[i:], m.CategoryCover)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.CategoryCover)))
		i--
		dAtA[i] = 0x12
	}
	if m.CategoryId != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.CategoryId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListDocumentForHomeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDocumentForHomeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDocumentForHomeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Document) > 0 {
		for iNdEx := len(m.Document) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Document[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDocument(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchDocumentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchDocumentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchDocumentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ext) > 0 {
		i -= len(m.Ext)
		copy(dAtA[i:], m.Ext)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Ext)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Sort) > 0 {
		i -= len(m.Sort)
		copy(dAtA[i:], m.Sort)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Sort)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CategoryId) > 0 {
		dAtA28 := make([]byte, len(m.CategoryId)*10)
		var j27 int
		for _, num1 := range m.CategoryId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintDocument(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Wd) > 0 {
		i -= len(m.Wd)
		copy(dAtA[i:], m.Wd)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Wd)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Size_ != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Page != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DocumentScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdatedAt != nil {
		n29, err29 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpdatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt):])
		if err29 != nil {
			return 0, err29
		}
		i -= n29
		i = encodeVarintDocument(dAtA, i, uint64(n29))
		i--
		dAtA[i] = 0x32
	}
	if m.CreatedAt != nil {
		n30, err30 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CreatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt):])
		if err30 != nil {
			return 0, err30
		}
		i -= n30
		i = encodeVarintDocument(dAtA, i, uint64(n30))
		i--
		dAtA[i] = 0x2a
	}
	if m.Score != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.DocumentId != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.DocumentId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchDocumentReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchDocumentReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchDocumentReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Document) > 0 {
		for iNdEx := len(m.Document) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Document[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDocument(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Spend) > 0 {
		i -= len(m.Spend)
		copy(dAtA[i:], m.Spend)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Spend)))
		i--
		dAtA[i] = 0x12
	}
	if m.Total != 0 {
		i = encodeVarintDocument(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DownloadDocumentReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadDocumentReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadDocumentReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintDocument(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDocument(dAtA []byte, offset int, v uint64) int {
	offset -= sovDocument(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Document) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDocument(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	l = len(m.Keywords)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovDocument(uint64(m.UserId))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovDocument(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovDocument(uint64(m.Height))
	}
	if m.Preview != 0 {
		n += 1 + sovDocument(uint64(m.Preview))
	}
	if m.Pages != 0 {
		n += 1 + sovDocument(uint64(m.Pages))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	if m.DownloadCount != 0 {
		n += 1 + sovDocument(uint64(m.DownloadCount))
	}
	if m.ViewCount != 0 {
		n += 1 + sovDocument(uint64(m.ViewCount))
	}
	if m.FavoriteCount != 0 {
		n += 1 + sovDocument(uint64(m.FavoriteCount))
	}
	if m.CommentCount != 0 {
		n += 1 + sovDocument(uint64(m.CommentCount))
	}
	if m.Score != 0 {
		n += 2 + sovDocument(uint64(m.Score))
	}
	if m.ScoreCount != 0 {
		n += 2 + sovDocument(uint64(m.ScoreCount))
	}
	if m.Price != 0 {
		n += 2 + sovDocument(uint64(m.Price))
	}
	if m.Size_ != 0 {
		n += 2 + sovDocument(uint64(m.Size_))
	}
	if m.Status != 0 {
		n += 2 + sovDocument(uint64(m.Status))
	}
	if m.CreatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt)
		n += 2 + l + sovDocument(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)
		n += 2 + l + sovDocument(uint64(l))
	}
	if m.DeletedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.DeletedAt)
		n += 2 + l + sovDocument(uint64(l))
	}
	if m.DeletedUserId != 0 {
		n += 2 + sovDocument(uint64(m.DeletedUserId))
	}
	l = len(m.Username)
	if l > 0 {
		n += 2 + l + sovDocument(uint64(l))
	}
	if len(m.CategoryId) > 0 {
		l = 0
		for _, e := range m.CategoryId {
			l += sovDocument(uint64(e))
		}
		n += 2 + sovDocument(uint64(l)) + l
	}
	l = len(m.DeletedUsername)
	if l > 0 {
		n += 2 + l + sovDocument(uint64(l))
	}
	l = len(m.Ext)
	if l > 0 {
		n += 2 + l + sovDocument(uint64(l))
	}
	if m.RecommendAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.RecommendAt)
		n += 2 + l + sovDocument(uint64(l))
	}
	if m.Attachment != nil {
		l = m.Attachment.Size()
		n += 2 + l + sovDocument(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 2 + l + sovDocument(uint64(l))
	}
	if m.EnableGzip {
		n += 3
	}
	l = len(m.ConvertError)
	if l > 0 {
		n += 2 + l + sovDocument(uint64(l))
	}
	return n
}

func (m *DeleteDocumentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovDocument(uint64(e))
		}
		n += 1 + sovDocument(uint64(l)) + l
	}
	return n
}

func (m *RecoverRecycleDocumentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovDocument(uint64(e))
		}
		n += 1 + sovDocument(uint64(l)) + l
	}
	return n
}

func (m *GetDocumentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDocument(uint64(m.Id))
	}
	if m.WithAuthor {
		n += 2
	}
	return n
}

func (m *SetDocumentsCategoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DocumentId) > 0 {
		l = 0
		for _, e := range m.DocumentId {
			l += sovDocument(uint64(e))
		}
		n += 1 + sovDocument(uint64(l)) + l
	}
	if len(m.CategoryId) > 0 {
		l = 0
		for _, e := range m.CategoryId {
			l += sovDocument(uint64(e))
		}
		n += 1 + sovDocument(uint64(l)) + l
	}
	return n
}

func (m *ListDocumentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovDocument(uint64(m.Page))
	}
	if m.Size_ != 0 {
		n += 1 + sovDocument(uint64(m.Size_))
	}
	l = len(m.Wd)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	if len(m.Field) > 0 {
		for _, s := range m.Field {
			l = len(s)
			n += 1 + l + sovDocument(uint64(l))
		}
	}
	l = len(m.Order)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	if len(m.CategoryId) > 0 {
		l = 0
		for _, e := range m.CategoryId {
			l += sovDocument(uint64(e))
		}
		n += 1 + sovDocument(uint64(l)) + l
	}
	if len(m.UserId) > 0 {
		l = 0
		for _, e := range m.UserId {
			l += sovDocument(uint64(e))
		}
		n += 1 + sovDocument(uint64(l)) + l
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovDocument(uint64(e))
		}
		n += 1 + sovDocument(uint64(l)) + l
	}
	if len(m.IsRecommend) > 0 {
		n += 1 + sovDocument(uint64(len(m.IsRecommend))) + len(m.IsRecommend)*1
	}
	if m.Limit != 0 {
		n += 1 + sovDocument(uint64(m.Limit))
	}
	l = len(m.Ext)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	return n
}

func (m *ListDocumentReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovDocument(uint64(m.Total))
	}
	if len(m.Document) > 0 {
		for _, e := range m.Document {
			l = e.Size()
			n += 1 + l + sovDocument(uint64(l))
		}
	}
	return n
}

func (m *CreateDocumentItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	if m.AttachmentId != 0 {
		n += 1 + sovDocument(uint64(m.AttachmentId))
	}
	if m.Price != 0 {
		n += 1 + sovDocument(uint64(m.Price))
	}
	return n
}

func (m *CreateDocumentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Overwrite {
		n += 2
	}
	if len(m.CategoryId) > 0 {
		l = 0
		for _, e := range m.CategoryId {
			l += sovDocument(uint64(e))
		}
		n += 1 + sovDocument(uint64(l)) + l
	}
	if len(m.Document) > 0 {
		for _, e := range m.Document {
			l = e.Size()
			n += 1 + l + sovDocument(uint64(l))
		}
	}
	return n
}

func (m *SetDocumentRecommendRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovDocument(uint64(e))
		}
		n += 1 + sovDocument(uint64(l)) + l
	}
	if m.Type != 0 {
		n += 1 + sovDocument(uint64(m.Type))
	}
	return n
}

func (m *ListDocumentForHomeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovDocument(uint64(m.Limit))
	}
	return n
}

func (m *ListDocumentForHomeItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CategoryId != 0 {
		n += 1 + sovDocument(uint64(m.CategoryId))
	}
	l = len(m.CategoryCover)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	l = len(m.CategoryName)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	if len(m.Document) > 0 {
		for _, e := range m.Document {
			l = e.Size()
			n += 1 + l + sovDocument(uint64(l))
		}
	}
	return n
}

func (m *ListDocumentForHomeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Document) > 0 {
		for _, e := range m.Document {
			l = e.Size()
			n += 1 + l + sovDocument(uint64(l))
		}
	}
	return n
}

func (m *SearchDocumentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovDocument(uint64(m.Page))
	}
	if m.Size_ != 0 {
		n += 1 + sovDocument(uint64(m.Size_))
	}
	l = len(m.Wd)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	if len(m.CategoryId) > 0 {
		l = 0
		for _, e := range m.CategoryId {
			l += sovDocument(uint64(e))
		}
		n += 1 + sovDocument(uint64(l)) + l
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	l = len(m.Ext)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	return n
}

func (m *DocumentScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDocument(uint64(m.Id))
	}
	if m.DocumentId != 0 {
		n += 1 + sovDocument(uint64(m.DocumentId))
	}
	if m.UserId != 0 {
		n += 1 + sovDocument(uint64(m.UserId))
	}
	if m.Score != 0 {
		n += 1 + sovDocument(uint64(m.Score))
	}
	if m.CreatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt)
		n += 1 + l + sovDocument(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)
		n += 1 + l + sovDocument(uint64(l))
	}
	return n
}

func (m *SearchDocumentReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovDocument(uint64(m.Total))
	}
	l = len(m.Spend)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	if len(m.Document) > 0 {
		for _, e := range m.Document {
			l = e.Size()
			n += 1 + l + sovDocument(uint64(l))
		}
	}
	return n
}

func (m *DownloadDocumentReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovDocument(uint64(l))
	}
	return n
}

func sovDocument(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDocument(x uint64) (n int) {
	return sovDocument(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Document) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keywords = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			m.Preview = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Preview |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pages", wireType)
			}
			m.Pages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pages |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadCount", wireType)
			}
			m.DownloadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewCount", wireType)
			}
			m.ViewCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FavoriteCount", wireType)
			}
			m.FavoriteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FavoriteCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentCount", wireType)
			}
			m.CommentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommentCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreCount", wireType)
			}
			m.ScoreCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.DeletedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedUserId", wireType)
			}
			m.DeletedUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletedUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CategoryId = append(m.CategoryId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CategoryId) == 0 {
					m.CategoryId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CategoryId = append(m.CategoryId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletedUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecommendAt == nil {
				m.RecommendAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.RecommendAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attachment == nil {
				m.Attachment = &Attachment{}
			}
			if err := m.Attachment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGzip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableGzip = bool(v != 0)
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvertError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConvertError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteDocumentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteDocumentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteDocumentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoverRecycleDocumentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoverRecycleDocumentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoverRecycleDocumentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDocumentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDocumentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDocumentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithAuthor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithAuthor = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDocumentsCategoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDocumentsCategoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDocumentsCategoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DocumentId = append(m.DocumentId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DocumentId) == 0 {
					m.DocumentId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DocumentId = append(m.DocumentId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentId", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CategoryId = append(m.CategoryId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CategoryId) == 0 {
					m.CategoryId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CategoryId = append(m.CategoryId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDocumentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDocumentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDocumentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = append(m.Field, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CategoryId = append(m.CategoryId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CategoryId) == 0 {
					m.CategoryId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CategoryId = append(m.CategoryId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserId = append(m.UserId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserId) == 0 {
					m.UserId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserId = append(m.UserId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		case 9:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IsRecommend = append(m.IsRecommend, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.IsRecommend) == 0 {
					m.IsRecommend = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IsRecommend = append(m.IsRecommend, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecommend", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDocumentReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDocumentReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDocumentReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = append(m.Document, &Document{})
			if err := m.Document[len(m.Document)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDocumentItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDocumentItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDocumentItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentId", wireType)
			}
			m.AttachmentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttachmentId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDocumentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDocumentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDocumentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overwrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overwrite = bool(v != 0)
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CategoryId = append(m.CategoryId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CategoryId) == 0 {
					m.CategoryId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CategoryId = append(m.CategoryId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = append(m.Document, &CreateDocumentItem{})
			if err := m.Document[len(m.Document)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDocumentRecommendRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDocumentRecommendRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDocumentRecommendRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDocumentForHomeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDocumentForHomeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDocumentForHomeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDocumentForHomeItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDocumentForHomeItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDocumentForHomeItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			m.CategoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CategoryId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryCover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryCover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = append(m.Document, &Document{})
			if err := m.Document[len(m.Document)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDocumentForHomeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDocumentForHomeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDocumentForHomeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = append(m.Document, &ListDocumentForHomeItem{})
			if err := m.Document[len(m.Document)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchDocumentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchDocumentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchDocumentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CategoryId = append(m.CategoryId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDocument
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDocument
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDocument
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CategoryId) == 0 {
					m.CategoryId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDocument
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CategoryId = append(m.CategoryId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentId", wireType)
			}
			m.DocumentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocumentId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchDocumentReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchDocumentReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchDocumentReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spend = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = append(m.Document, &Document{})
			if err := m.Document[len(m.Document)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadDocumentReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadDocumentReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadDocumentReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDocument
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDocument
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDocument(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDocument
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDocument(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDocument
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDocument
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDocument
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDocument
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDocument
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDocument        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDocument          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDocument = fmt.Errorf("proto: unexpected end of group")
)
