// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v1/article.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// 文章
type Article struct {
	Id            int64       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Identifier    string      `protobuf:"bytes,2,opt,name=identifier,proto3" json:"identifier,omitempty"`
	Author        string      `protobuf:"bytes,3,opt,name=author,proto3" json:"author,omitempty"`
	ViewCount     int64       `protobuf:"varint,4,opt,name=view_count,json=viewCount,proto3" json:"view_count,omitempty"`
	Title         string      `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	Keywords      string      `protobuf:"bytes,6,opt,name=keywords,proto3" json:"keywords,omitempty"`
	Description   string      `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	Content       string      `protobuf:"bytes,8,opt,name=content,proto3" json:"content,omitempty"`
	CreatedAt     *time.Time  `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at,omitempty"`
	UpdatedAt     *time.Time  `protobuf:"bytes,10,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at,omitempty"`
	DeletedAt     *time.Time  `protobuf:"bytes,11,opt,name=deleted_at,json=deletedAt,proto3,stdtime" json:"deleted_at,omitempty"`
	CategoryId    []int64     `protobuf:"varint,12,rep,packed,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
	FavoriteCount int64       `protobuf:"varint,13,opt,name=favorite_count,json=favoriteCount,proto3" json:"favorite_count,omitempty"`
	CommentCount  int64       `protobuf:"varint,14,opt,name=comment_count,json=commentCount,proto3" json:"comment_count,omitempty"`
	RecommendAt   *time.Time  `protobuf:"bytes,15,opt,name=recommend_at,json=recommendAt,proto3,stdtime" json:"recommend_at,omitempty"`
	IsRecommend   bool        `protobuf:"varint,16,opt,name=is_recommend,json=isRecommend,proto3" json:"is_recommend,omitempty"`
	UserId        int64       `protobuf:"varint,17,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	User          *User       `protobuf:"bytes,18,opt,name=user,proto3" json:"user,omitempty"`
	Status        int32       `protobuf:"varint,19,opt,name=status,proto3" json:"status,omitempty"`
	RejectReason  string      `protobuf:"bytes,20,opt,name=reject_reason,json=rejectReason,proto3" json:"reject_reason,omitempty"`
	Category      []*Category `protobuf:"bytes,21,rep,name=category,proto3" json:"category,omitempty"`
}

func (m *Article) Reset()         { *m = Article{} }
func (m *Article) String() string { return proto.CompactTextString(m) }
func (*Article) ProtoMessage()    {}
func (*Article) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5a9bcd2997b0bd3, []int{0}
}
func (m *Article) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Article) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Article.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Article) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Article.Merge(m, src)
}
func (m *Article) XXX_Size() int {
	return m.Size()
}
func (m *Article) XXX_DiscardUnknown() {
	xxx_messageInfo_Article.DiscardUnknown(m)
}

var xxx_messageInfo_Article proto.InternalMessageInfo

func (m *Article) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Article) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

func (m *Article) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Article) GetViewCount() int64 {
	if m != nil {
		return m.ViewCount
	}
	return 0
}

func (m *Article) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Article) GetKeywords() string {
	if m != nil {
		return m.Keywords
	}
	return ""
}

func (m *Article) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Article) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Article) GetCreatedAt() *time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Article) GetUpdatedAt() *time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *Article) GetDeletedAt() *time.Time {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *Article) GetCategoryId() []int64 {
	if m != nil {
		return m.CategoryId
	}
	return nil
}

func (m *Article) GetFavoriteCount() int64 {
	if m != nil {
		return m.FavoriteCount
	}
	return 0
}

func (m *Article) GetCommentCount() int64 {
	if m != nil {
		return m.CommentCount
	}
	return 0
}

func (m *Article) GetRecommendAt() *time.Time {
	if m != nil {
		return m.RecommendAt
	}
	return nil
}

func (m *Article) GetIsRecommend() bool {
	if m != nil {
		return m.IsRecommend
	}
	return false
}

func (m *Article) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Article) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Article) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Article) GetRejectReason() string {
	if m != nil {
		return m.RejectReason
	}
	return ""
}

func (m *Article) GetCategory() []*Category {
	if m != nil {
		return m.Category
	}
	return nil
}

// 删除文章请求，传入单个或者多个文章ID
type DeleteArticleRequest struct {
	Id []int64 `protobuf:"varint,1,rep,packed,name=id,proto3" json:"id,omitempty"`
}

func (m *DeleteArticleRequest) Reset()         { *m = DeleteArticleRequest{} }
func (m *DeleteArticleRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteArticleRequest) ProtoMessage()    {}
func (*DeleteArticleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5a9bcd2997b0bd3, []int{1}
}
func (m *DeleteArticleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteArticleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteArticleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteArticleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteArticleRequest.Merge(m, src)
}
func (m *DeleteArticleRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteArticleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteArticleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteArticleRequest proto.InternalMessageInfo

func (m *DeleteArticleRequest) GetId() []int64 {
	if m != nil {
		return m.Id
	}
	return nil
}

type RestoreArticleRequest struct {
	Id []int64 `protobuf:"varint,1,rep,packed,name=id,proto3" json:"id,omitempty"`
}

func (m *RestoreArticleRequest) Reset()         { *m = RestoreArticleRequest{} }
func (m *RestoreArticleRequest) String() string { return proto.CompactTextString(m) }
func (*RestoreArticleRequest) ProtoMessage()    {}
func (*RestoreArticleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5a9bcd2997b0bd3, []int{2}
}
func (m *RestoreArticleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreArticleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RestoreArticleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RestoreArticleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreArticleRequest.Merge(m, src)
}
func (m *RestoreArticleRequest) XXX_Size() int {
	return m.Size()
}
func (m *RestoreArticleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreArticleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreArticleRequest proto.InternalMessageInfo

func (m *RestoreArticleRequest) GetId() []int64 {
	if m != nil {
		return m.Id
	}
	return nil
}

type SetArticlesCategoryRequest struct {
	ArticleId  []int64 `protobuf:"varint,1,rep,packed,name=article_id,json=articleId,proto3" json:"article_id,omitempty"`
	CategoryId []int64 `protobuf:"varint,2,rep,packed,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
}

func (m *SetArticlesCategoryRequest) Reset()         { *m = SetArticlesCategoryRequest{} }
func (m *SetArticlesCategoryRequest) String() string { return proto.CompactTextString(m) }
func (*SetArticlesCategoryRequest) ProtoMessage()    {}
func (*SetArticlesCategoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5a9bcd2997b0bd3, []int{3}
}
func (m *SetArticlesCategoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetArticlesCategoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetArticlesCategoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetArticlesCategoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetArticlesCategoryRequest.Merge(m, src)
}
func (m *SetArticlesCategoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetArticlesCategoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetArticlesCategoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetArticlesCategoryRequest proto.InternalMessageInfo

func (m *SetArticlesCategoryRequest) GetArticleId() []int64 {
	if m != nil {
		return m.ArticleId
	}
	return nil
}

func (m *SetArticlesCategoryRequest) GetCategoryId() []int64 {
	if m != nil {
		return m.CategoryId
	}
	return nil
}

type RecommendArticlesRequest struct {
	ArticleId   []int64 `protobuf:"varint,1,rep,packed,name=article_id,json=articleId,proto3" json:"article_id,omitempty"`
	IsRecommend bool    `protobuf:"varint,2,opt,name=is_recommend,json=isRecommend,proto3" json:"is_recommend,omitempty"`
}

func (m *RecommendArticlesRequest) Reset()         { *m = RecommendArticlesRequest{} }
func (m *RecommendArticlesRequest) String() string { return proto.CompactTextString(m) }
func (*RecommendArticlesRequest) ProtoMessage()    {}
func (*RecommendArticlesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5a9bcd2997b0bd3, []int{4}
}
func (m *RecommendArticlesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendArticlesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecommendArticlesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecommendArticlesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendArticlesRequest.Merge(m, src)
}
func (m *RecommendArticlesRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecommendArticlesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendArticlesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendArticlesRequest proto.InternalMessageInfo

func (m *RecommendArticlesRequest) GetArticleId() []int64 {
	if m != nil {
		return m.ArticleId
	}
	return nil
}

func (m *RecommendArticlesRequest) GetIsRecommend() bool {
	if m != nil {
		return m.IsRecommend
	}
	return false
}

type CheckArticlesRequest struct {
	ArticleId     []int64 `protobuf:"varint,1,rep,packed,name=article_id,json=articleId,proto3" json:"article_id,omitempty"`
	Status        int32   `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	RejeactReason string  `protobuf:"bytes,3,opt,name=rejeact_reason,json=rejeactReason,proto3" json:"rejeact_reason,omitempty"`
}

func (m *CheckArticlesRequest) Reset()         { *m = CheckArticlesRequest{} }
func (m *CheckArticlesRequest) String() string { return proto.CompactTextString(m) }
func (*CheckArticlesRequest) ProtoMessage()    {}
func (*CheckArticlesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5a9bcd2997b0bd3, []int{5}
}
func (m *CheckArticlesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckArticlesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckArticlesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckArticlesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckArticlesRequest.Merge(m, src)
}
func (m *CheckArticlesRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckArticlesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckArticlesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckArticlesRequest proto.InternalMessageInfo

func (m *CheckArticlesRequest) GetArticleId() []int64 {
	if m != nil {
		return m.ArticleId
	}
	return nil
}

func (m *CheckArticlesRequest) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *CheckArticlesRequest) GetRejeactReason() string {
	if m != nil {
		return m.RejeactReason
	}
	return ""
}

// 根据ID或者文章标识获取文章，二选一
type GetArticleRequest struct {
	Id         int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Identifier string `protobuf:"bytes,2,opt,name=identifier,proto3" json:"identifier,omitempty"`
}

func (m *GetArticleRequest) Reset()         { *m = GetArticleRequest{} }
func (m *GetArticleRequest) String() string { return proto.CompactTextString(m) }
func (*GetArticleRequest) ProtoMessage()    {}
func (*GetArticleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5a9bcd2997b0bd3, []int{6}
}
func (m *GetArticleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetArticleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetArticleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetArticleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetArticleRequest.Merge(m, src)
}
func (m *GetArticleRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetArticleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetArticleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetArticleRequest proto.InternalMessageInfo

func (m *GetArticleRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GetArticleRequest) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

// 文章列表请求
type ListArticleRequest struct {
	Page        int64    `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
	Size_       int64    `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Wd          string   `protobuf:"bytes,3,opt,name=wd,proto3" json:"wd,omitempty"`
	Field       []string `protobuf:"bytes,4,rep,name=field,proto3" json:"field,omitempty"`
	Order       string   `protobuf:"bytes,5,opt,name=order,proto3" json:"order,omitempty"`
	CategoryId  []int64  `protobuf:"varint,6,rep,packed,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
	IsRecommend []bool   `protobuf:"varint,7,rep,packed,name=is_recommend,json=isRecommend,proto3" json:"is_recommend,omitempty"`
	Status      []int32  `protobuf:"varint,8,rep,packed,name=status,proto3" json:"status,omitempty"`
	UserId      []int64  `protobuf:"varint,9,rep,packed,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	CreatedAt   []string `protobuf:"bytes,10,rep,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Sort        string   `protobuf:"bytes,11,opt,name=sort,proto3" json:"sort,omitempty"`
}

func (m *ListArticleRequest) Reset()         { *m = ListArticleRequest{} }
func (m *ListArticleRequest) String() string { return proto.CompactTextString(m) }
func (*ListArticleRequest) ProtoMessage()    {}
func (*ListArticleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5a9bcd2997b0bd3, []int{7}
}
func (m *ListArticleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListArticleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListArticleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListArticleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListArticleRequest.Merge(m, src)
}
func (m *ListArticleRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListArticleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListArticleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListArticleRequest proto.InternalMessageInfo

func (m *ListArticleRequest) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListArticleRequest) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *ListArticleRequest) GetWd() string {
	if m != nil {
		return m.Wd
	}
	return ""
}

func (m *ListArticleRequest) GetField() []string {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *ListArticleRequest) GetOrder() string {
	if m != nil {
		return m.Order
	}
	return ""
}

func (m *ListArticleRequest) GetCategoryId() []int64 {
	if m != nil {
		return m.CategoryId
	}
	return nil
}

func (m *ListArticleRequest) GetIsRecommend() []bool {
	if m != nil {
		return m.IsRecommend
	}
	return nil
}

func (m *ListArticleRequest) GetStatus() []int32 {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ListArticleRequest) GetUserId() []int64 {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *ListArticleRequest) GetCreatedAt() []string {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *ListArticleRequest) GetSort() string {
	if m != nil {
		return m.Sort
	}
	return ""
}

// 文章列表响应
type ListArticleReply struct {
	Total   int64      `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Article []*Article `protobuf:"bytes,2,rep,name=article,proto3" json:"article,omitempty"`
}

func (m *ListArticleReply) Reset()         { *m = ListArticleReply{} }
func (m *ListArticleReply) String() string { return proto.CompactTextString(m) }
func (*ListArticleReply) ProtoMessage()    {}
func (*ListArticleReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5a9bcd2997b0bd3, []int{8}
}
func (m *ListArticleReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListArticleReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListArticleReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListArticleReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListArticleReply.Merge(m, src)
}
func (m *ListArticleReply) XXX_Size() int {
	return m.Size()
}
func (m *ListArticleReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ListArticleReply.DiscardUnknown(m)
}

var xxx_messageInfo_ListArticleReply proto.InternalMessageInfo

func (m *ListArticleReply) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ListArticleReply) GetArticle() []*Article {
	if m != nil {
		return m.Article
	}
	return nil
}

// 文档搜索响应
type SearchArticleReply struct {
	Total   int64      `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Spend   string     `protobuf:"bytes,2,opt,name=spend,proto3" json:"spend,omitempty"`
	Article []*Article `protobuf:"bytes,3,rep,name=article,proto3" json:"article,omitempty"`
}

func (m *SearchArticleReply) Reset()         { *m = SearchArticleReply{} }
func (m *SearchArticleReply) String() string { return proto.CompactTextString(m) }
func (*SearchArticleReply) ProtoMessage()    {}
func (*SearchArticleReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5a9bcd2997b0bd3, []int{9}
}
func (m *SearchArticleReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchArticleReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchArticleReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchArticleReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchArticleReply.Merge(m, src)
}
func (m *SearchArticleReply) XXX_Size() int {
	return m.Size()
}
func (m *SearchArticleReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchArticleReply.DiscardUnknown(m)
}

var xxx_messageInfo_SearchArticleReply proto.InternalMessageInfo

func (m *SearchArticleReply) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *SearchArticleReply) GetSpend() string {
	if m != nil {
		return m.Spend
	}
	return ""
}

func (m *SearchArticleReply) GetArticle() []*Article {
	if m != nil {
		return m.Article
	}
	return nil
}

func init() {
	proto.RegisterType((*Article)(nil), "api.v1.Article")
	proto.RegisterType((*DeleteArticleRequest)(nil), "api.v1.DeleteArticleRequest")
	proto.RegisterType((*RestoreArticleRequest)(nil), "api.v1.RestoreArticleRequest")
	proto.RegisterType((*SetArticlesCategoryRequest)(nil), "api.v1.SetArticlesCategoryRequest")
	proto.RegisterType((*RecommendArticlesRequest)(nil), "api.v1.RecommendArticlesRequest")
	proto.RegisterType((*CheckArticlesRequest)(nil), "api.v1.CheckArticlesRequest")
	proto.RegisterType((*GetArticleRequest)(nil), "api.v1.GetArticleRequest")
	proto.RegisterType((*ListArticleRequest)(nil), "api.v1.ListArticleRequest")
	proto.RegisterType((*ListArticleReply)(nil), "api.v1.ListArticleReply")
	proto.RegisterType((*SearchArticleReply)(nil), "api.v1.SearchArticleReply")
}

func init() { proto.RegisterFile("api/v1/article.proto", fileDescriptor_d5a9bcd2997b0bd3) }

var fileDescriptor_d5a9bcd2997b0bd3 = []byte{
	// 1194 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4f, 0x6f, 0xe3, 0xc4,
	0x1b, 0xae, 0x93, 0x36, 0x69, 0xde, 0x24, 0x6d, 0x33, 0x4d, 0x5b, 0xd7, 0xbf, 0x26, 0xf1, 0xcf,
	0xbb, 0x85, 0x50, 0xa1, 0x44, 0x2d, 0xe2, 0x02, 0x07, 0xd4, 0x0d, 0x68, 0x55, 0x09, 0xa4, 0xc5,
	0xdd, 0xbd, 0xa0, 0x15, 0x91, 0xd7, 0x9e, 0xa6, 0xde, 0x26, 0xb1, 0xb1, 0x27, 0xa9, 0xb2, 0x47,
	0x3e, 0xc1, 0x4a, 0x5c, 0x39, 0xf0, 0x45, 0xb8, 0x73, 0x5c, 0x89, 0x0b, 0x37, 0x50, 0xcb, 0x07,
	0x41, 0xf3, 0x7a, 0xc6, 0x49, 0x9c, 0xb8, 0x04, 0xb8, 0x79, 0x9e, 0x99, 0x79, 0x9e, 0x99, 0xf7,
	0xcf, 0x33, 0x09, 0x54, 0x2d, 0xdf, 0x6d, 0x8f, 0x4f, 0xdb, 0x56, 0xc0, 0x5c, 0xbb, 0x4f, 0x5b,
	0x7e, 0xe0, 0x31, 0x8f, 0xe4, 0x2c, 0xdf, 0x6d, 0x8d, 0x4f, 0xb5, 0x46, 0xcf, 0xf3, 0x7a, 0x7d,
	0xda, 0x46, 0xf4, 0xd5, 0xe8, 0xaa, 0xcd, 0xdc, 0x01, 0x0d, 0x99, 0x35, 0xf0, 0xa3, 0x85, 0x5a,
	0xb5, 0xe7, 0xf5, 0x3c, 0xfc, 0x6c, 0xf3, 0x2f, 0x81, 0x1e, 0x89, 0x6d, 0x9c, 0xdb, 0x1a, 0x0e,
	0x3d, 0x66, 0x31, 0xd7, 0x1b, 0x86, 0x62, 0xf6, 0x7f, 0x49, 0x52, 0x3a, 0xf0, 0xd9, 0x44, 0x4c,
	0x56, 0xc4, 0x79, 0x46, 0x21, 0x0d, 0x04, 0xb4, 0x27, 0x20, 0xdb, 0x62, 0xb4, 0xe7, 0x05, 0x62,
	0xa5, 0xf1, 0x63, 0x0e, 0xf2, 0xe7, 0xd1, 0xa9, 0xc9, 0x16, 0x64, 0x5c, 0x47, 0x55, 0x74, 0xa5,
	0x99, 0x35, 0x33, 0xae, 0x43, 0xea, 0x00, 0xae, 0x43, 0x87, 0xcc, 0xbd, 0x72, 0x69, 0xa0, 0x66,
	0x74, 0xa5, 0x59, 0x30, 0x67, 0x10, 0xb2, 0x0f, 0x39, 0x6b, 0xc4, 0xae, 0xbd, 0x40, 0xcd, 0xe2,
	0x9c, 0x18, 0x91, 0x1a, 0xc0, 0xd8, 0xa5, 0xb7, 0x5d, 0xdb, 0x1b, 0x0d, 0x99, 0xba, 0x8e, 0x7c,
	0x05, 0x8e, 0x74, 0x38, 0x40, 0xaa, 0xb0, 0xc1, 0x5c, 0xd6, 0xa7, 0xea, 0x06, 0xee, 0x8a, 0x06,
	0x44, 0x83, 0xcd, 0x1b, 0x3a, 0xb9, 0xf5, 0x02, 0x27, 0x54, 0x73, 0x38, 0x11, 0x8f, 0x89, 0x0e,
	0x45, 0x87, 0x86, 0x76, 0xe0, 0xfa, 0x3c, 0x02, 0x6a, 0x1e, 0xa7, 0x67, 0x21, 0xa2, 0x42, 0xde,
	0xf6, 0x86, 0x8c, 0x0e, 0x99, 0xba, 0x89, 0xb3, 0x72, 0x48, 0x3e, 0x03, 0xb0, 0x03, 0x6a, 0x31,
	0xea, 0x74, 0x2d, 0xa6, 0x16, 0x74, 0xa5, 0x59, 0x3c, 0xd3, 0x5a, 0x51, 0xf0, 0x5a, 0x32, 0x78,
	0xad, 0xe7, 0x32, 0x23, 0x4f, 0xd6, 0xdf, 0xfe, 0xde, 0x50, 0xcc, 0x82, 0xd8, 0x73, 0x8e, 0x04,
	0x23, 0xdf, 0x91, 0x04, 0xb0, 0x2a, 0x81, 0xd8, 0x13, 0x11, 0x38, 0xb4, 0x4f, 0x05, 0x41, 0x71,
	0x55, 0x02, 0xb1, 0xe7, 0x9c, 0x91, 0x06, 0x14, 0x65, 0xd6, 0xba, 0xae, 0xa3, 0x96, 0xf4, 0x6c,
	0x33, 0x6b, 0x82, 0x84, 0x2e, 0x1c, 0x72, 0x0c, 0x5b, 0x57, 0xd6, 0xd8, 0x0b, 0x5c, 0x46, 0x45,
	0xd0, 0xcb, 0x18, 0xf4, 0xb2, 0x44, 0xa3, 0xc0, 0x3f, 0x82, 0xb2, 0xed, 0x0d, 0x06, 0x74, 0xc8,
	0xc4, 0xaa, 0x2d, 0x5c, 0x55, 0x12, 0x60, 0xb4, 0xa8, 0x03, 0xa5, 0x80, 0x46, 0x08, 0x9e, 0x77,
	0x7b, 0xc5, 0xf3, 0x16, 0xe3, 0x5d, 0xe7, 0x8c, 0xfc, 0x1f, 0x4a, 0x6e, 0xd8, 0x8d, 0x11, 0x75,
	0x47, 0x57, 0x9a, 0x9b, 0x66, 0xd1, 0x0d, 0x4d, 0x09, 0x91, 0x03, 0xc8, 0xf3, 0xea, 0xe4, 0x17,
	0xaa, 0xe0, 0x31, 0x72, 0x7c, 0x78, 0xe1, 0x10, 0x1d, 0xd6, 0xf9, 0x97, 0x4a, 0x50, 0xb8, 0xd4,
	0x8a, 0x9a, 0xa8, 0xf5, 0x22, 0xa4, 0x81, 0x89, 0x33, 0xbc, 0xee, 0x42, 0x66, 0xb1, 0x51, 0xa8,
	0xee, 0xea, 0x4a, 0x73, 0xc3, 0x14, 0x23, 0x7e, 0xbf, 0x80, 0xbe, 0xa6, 0x36, 0xeb, 0x06, 0xd4,
	0x0a, 0xbd, 0xa1, 0x5a, 0xc5, 0x52, 0x28, 0x45, 0xa0, 0x89, 0x18, 0xf9, 0x10, 0x36, 0x65, 0xe4,
	0xd4, 0x3d, 0x3d, 0xdb, 0x2c, 0x9e, 0xed, 0x48, 0x89, 0x8e, 0xc0, 0xcd, 0x78, 0x85, 0xf1, 0x1e,
	0x54, 0x3f, 0xc7, 0x3c, 0x88, 0x1e, 0x31, 0xe9, 0x77, 0x23, 0x1a, 0xb2, 0xb8, 0x55, 0xb2, 0x51,
	0xab, 0x18, 0xef, 0xc3, 0x9e, 0x49, 0x43, 0xe6, 0x05, 0x7f, 0xb7, 0xf0, 0x25, 0x68, 0x97, 0x94,
	0x89, 0x45, 0x61, 0xac, 0x28, 0x56, 0xd7, 0x00, 0x84, 0x85, 0x74, 0xe3, 0x5d, 0x05, 0x81, 0x5c,
	0x38, 0xc9, 0x42, 0xc8, 0x24, 0x0b, 0xc1, 0x78, 0x09, 0x6a, 0x1c, 0x61, 0xa9, 0xb1, 0x22, 0x77,
	0x32, 0x65, 0x99, 0x85, 0x94, 0x19, 0x0c, 0xaa, 0x9d, 0x6b, 0x6a, 0xdf, 0xfc, 0x43, 0xe6, 0x69,
	0xba, 0x32, 0x73, 0xe9, 0x3a, 0x86, 0x2d, 0x9e, 0x19, 0x6b, 0x9a, 0xaf, 0xc8, 0x46, 0xca, 0x02,
	0x8d, 0x12, 0x66, 0x74, 0xa0, 0xf2, 0x34, 0x8e, 0x58, 0x32, 0xac, 0x2b, 0x5a, 0x95, 0xf1, 0x53,
	0x06, 0xc8, 0x97, 0x6e, 0x98, 0xa4, 0x21, 0xb0, 0xee, 0x5b, 0x3d, 0x2a, 0x88, 0xf0, 0x9b, 0x63,
	0xa1, 0xfb, 0x86, 0x22, 0x49, 0xd6, 0xc4, 0x6f, 0x2e, 0x77, 0xeb, 0x88, 0xe3, 0x65, 0x6e, 0x1d,
	0x6e, 0x61, 0x57, 0x2e, 0xed, 0x3b, 0xea, 0xba, 0x9e, 0xe5, 0x16, 0x86, 0x03, 0x8e, 0x7a, 0x81,
	0x43, 0x03, 0x69, 0x6c, 0x38, 0x48, 0x26, 0x2d, 0xb7, 0xd0, 0xbd, 0xc9, 0xc8, 0xe7, 0xf5, 0x6c,
	0xb2, 0x59, 0xa6, 0x21, 0xdc, 0xd4, 0xb3, 0x33, 0x21, 0x9c, 0x69, 0xa2, 0x02, 0xf2, 0xca, 0x26,
	0xaa, 0xcd, 0xb9, 0x1e, 0xe0, 0x29, 0x67, 0x3c, 0x8d, 0xdf, 0xd1, 0x0b, 0x22, 0x33, 0x2a, 0x98,
	0xf8, 0x6d, 0x5c, 0xc2, 0xce, 0x5c, 0x84, 0xfc, 0xfe, 0x04, 0xad, 0xda, 0x63, 0x56, 0x5f, 0x04,
	0x28, 0x1a, 0x90, 0x0f, 0x20, 0x2f, 0xb2, 0x8b, 0x25, 0x58, 0x3c, 0xdb, 0x96, 0x1d, 0x24, 0x37,
	0xcb, 0x79, 0xe3, 0x06, 0xc8, 0x25, 0xb5, 0x02, 0xfb, 0x7a, 0x05, 0xda, 0x2a, 0x6c, 0x84, 0xbe,
	0x2c, 0xbd, 0x82, 0x19, 0x0d, 0x66, 0xc5, 0xb2, 0x0f, 0x8b, 0x9d, 0xfd, 0x5c, 0x04, 0x10, 0xe0,
	0xf9, 0xb3, 0x0b, 0xf2, 0x15, 0x94, 0x3b, 0x78, 0x63, 0xf9, 0xbe, 0x25, 0x77, 0x6a, 0x49, 0xc0,
	0xd0, 0xbe, 0xff, 0xf5, 0xcf, 0x1f, 0x32, 0x55, 0x63, 0xbb, 0x3d, 0xff, 0xa0, 0x7f, 0xa2, 0x9c,
	0x90, 0xe7, 0x50, 0x7e, 0x81, 0x9e, 0x9e, 0x4a, 0xb7, 0xbf, 0x60, 0x92, 0x5f, 0xf0, 0x37, 0x59,
	0xb2, 0x6a, 0xcb, 0x58, 0xbf, 0x85, 0xf2, 0x9c, 0xc1, 0x90, 0x23, 0xc9, 0xba, 0xcc, 0x77, 0x52,
	0x25, 0x0e, 0x50, 0xa2, 0x72, 0x92, 0x94, 0x20, 0x5f, 0x03, 0x4c, 0xbb, 0x87, 0x1c, 0x4a, 0xf2,
	0x85, 0x8e, 0x5a, 0x8c, 0x85, 0xa0, 0x24, 0x0b, 0x94, 0x16, 0x14, 0x67, 0x0a, 0x85, 0x68, 0x72,
	0xe3, 0x62, 0x7f, 0x69, 0xea, 0xd2, 0x39, 0xbf, 0x3f, 0x31, 0x8e, 0x90, 0x7d, 0x9f, 0x54, 0x13,
	0xec, 0xed, 0xbe, 0x1b, 0x32, 0x32, 0x86, 0xdd, 0x25, 0x2e, 0x49, 0x0c, 0x49, 0x97, 0x6e, 0xa1,
	0xa9, 0x11, 0x7a, 0x84, 0x82, 0x35, 0x4d, 0x4d, 0x0a, 0xca, 0x4e, 0xe4, 0xd9, 0x08, 0xa1, 0xb2,
	0xe0, 0x9f, 0x44, 0x97, 0xaa, 0x69, 0xd6, 0x9a, 0xaa, 0xf9, 0x18, 0x35, 0xeb, 0xda, 0x61, 0x52,
	0x33, 0x6e, 0x76, 0x2e, 0xda, 0x83, 0xf2, 0x9c, 0xad, 0x4e, 0x4b, 0x60, 0x99, 0xdb, 0xa6, 0x8a,
	0xe9, 0x28, 0xa6, 0x69, 0x7b, 0x0b, 0x17, 0xe4, 0x2c, 0x5c, 0xc8, 0x8f, 0x3c, 0xd0, 0xa4, 0xf6,
	0x84, 0xb7, 0xc8, 0x7f, 0xca, 0x9f, 0xb8, 0x1a, 0x39, 0x5a, 0x72, 0xb5, 0x49, 0x9c, 0xc7, 0x37,
	0xf1, 0xb3, 0x98, 0x10, 0xad, 0x4d, 0x63, 0xba, 0xe4, 0xd5, 0x4c, 0xbd, 0xe3, 0x09, 0xaa, 0x3e,
	0x36, 0x1a, 0x69, 0xaa, 0x41, 0x44, 0xc7, 0x6f, 0x3b, 0x90, 0x4f, 0x77, 0x42, 0xfa, 0xdf, 0x35,
	0x58, 0x03, 0x95, 0x0f, 0x4f, 0x0e, 0x52, 0x94, 0x49, 0x1f, 0x76, 0x71, 0x65, 0x42, 0x2d, 0x85,
	0x2f, 0x55, 0xe7, 0x18, 0x75, 0x1a, 0x27, 0xb5, 0xb4, 0x1b, 0xe2, 0xcf, 0x7c, 0x5e, 0x33, 0x73,
	0xbe, 0xfa, 0x60, 0x16, 0xb5, 0x69, 0xdb, 0x24, 0xad, 0xd8, 0xa8, 0xa3, 0x9e, 0x4a, 0xf6, 0x93,
	0x7a, 0x21, 0xae, 0x25, 0xaf, 0x81, 0x3c, 0xa5, 0xcc, 0xa4, 0x7d, 0x7c, 0x39, 0x64, 0x85, 0x3e,
	0xe0, 0x23, 0xe9, 0x25, 0x23, 0x42, 0x48, 0x96, 0x84, 0x10, 0xd9, 0x9f, 0x7c, 0xfc, 0xcb, 0x5d,
	0x5d, 0x79, 0x77, 0x57, 0x57, 0xfe, 0xb8, 0xab, 0x2b, 0x6f, 0xef, 0xeb, 0x6b, 0xef, 0xee, 0xeb,
	0x6b, 0xbf, 0xdd, 0xd7, 0xd7, 0x40, 0xfc, 0x93, 0x7a, 0xa6, 0x7c, 0x53, 0x19, 0x78, 0x01, 0x75,
	0x3c, 0x5b, 0x70, 0x7c, 0x3a, 0x3e, 0x7d, 0x95, 0xc3, 0x10, 0x7e, 0xf4, 0x57, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x6c, 0x3b, 0xfa, 0x1d, 0x85, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ArticleAPIClient is the client API for ArticleAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ArticleAPIClient interface {
	// 创建文章
	CreateArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Article, error)
	// 更新文章
	UpdateArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 删除文章
	DeleteArticle(ctx context.Context, in *DeleteArticleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 获取文章
	GetArticle(ctx context.Context, in *GetArticleRequest, opts ...grpc.CallOption) (*Article, error)
	// 文章列表
	ListArticle(ctx context.Context, in *ListArticleRequest, opts ...grpc.CallOption) (*ListArticleReply, error)
	// 批量更新文档分类
	SetArticlesCategory(ctx context.Context, in *SetArticlesCategoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 批量推荐
	RecommendArticles(ctx context.Context, in *RecommendArticlesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 批量审核文档
	CheckArticles(ctx context.Context, in *CheckArticlesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 回收站文章列表
	ListRecycleArticle(ctx context.Context, in *ListArticleRequest, opts ...grpc.CallOption) (*ListArticleReply, error)
	// 恢复回收站文章
	RestoreRecycleArticle(ctx context.Context, in *RestoreArticleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 从回收站删除文章
	DeleteRecycleArticle(ctx context.Context, in *DeleteArticleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 清空回收站
	EmptyRecycleArticle(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 搜索文章
	SearchArticle(ctx context.Context, in *ListArticleRequest, opts ...grpc.CallOption) (*SearchArticleReply, error)
	// 相关文章
	GetRelatedArticles(ctx context.Context, in *GetArticleRequest, opts ...grpc.CallOption) (*ListArticleReply, error)
}

type articleAPIClient struct {
	cc *grpc.ClientConn
}

func NewArticleAPIClient(cc *grpc.ClientConn) ArticleAPIClient {
	return &articleAPIClient{cc}
}

func (c *articleAPIClient) CreateArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Article, error) {
	out := new(Article)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/CreateArticle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) UpdateArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/UpdateArticle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) DeleteArticle(ctx context.Context, in *DeleteArticleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/DeleteArticle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) GetArticle(ctx context.Context, in *GetArticleRequest, opts ...grpc.CallOption) (*Article, error) {
	out := new(Article)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/GetArticle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) ListArticle(ctx context.Context, in *ListArticleRequest, opts ...grpc.CallOption) (*ListArticleReply, error) {
	out := new(ListArticleReply)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/ListArticle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) SetArticlesCategory(ctx context.Context, in *SetArticlesCategoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/SetArticlesCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) RecommendArticles(ctx context.Context, in *RecommendArticlesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/RecommendArticles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) CheckArticles(ctx context.Context, in *CheckArticlesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/CheckArticles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) ListRecycleArticle(ctx context.Context, in *ListArticleRequest, opts ...grpc.CallOption) (*ListArticleReply, error) {
	out := new(ListArticleReply)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/ListRecycleArticle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) RestoreRecycleArticle(ctx context.Context, in *RestoreArticleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/RestoreRecycleArticle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) DeleteRecycleArticle(ctx context.Context, in *DeleteArticleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/DeleteRecycleArticle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) EmptyRecycleArticle(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/EmptyRecycleArticle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) SearchArticle(ctx context.Context, in *ListArticleRequest, opts ...grpc.CallOption) (*SearchArticleReply, error) {
	out := new(SearchArticleReply)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/SearchArticle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleAPIClient) GetRelatedArticles(ctx context.Context, in *GetArticleRequest, opts ...grpc.CallOption) (*ListArticleReply, error) {
	out := new(ListArticleReply)
	err := c.cc.Invoke(ctx, "/api.v1.ArticleAPI/GetRelatedArticles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArticleAPIServer is the server API for ArticleAPI service.
type ArticleAPIServer interface {
	// 创建文章
	CreateArticle(context.Context, *Article) (*Article, error)
	// 更新文章
	UpdateArticle(context.Context, *Article) (*emptypb.Empty, error)
	// 删除文章
	DeleteArticle(context.Context, *DeleteArticleRequest) (*emptypb.Empty, error)
	// 获取文章
	GetArticle(context.Context, *GetArticleRequest) (*Article, error)
	// 文章列表
	ListArticle(context.Context, *ListArticleRequest) (*ListArticleReply, error)
	// 批量更新文档分类
	SetArticlesCategory(context.Context, *SetArticlesCategoryRequest) (*emptypb.Empty, error)
	// 批量推荐
	RecommendArticles(context.Context, *RecommendArticlesRequest) (*emptypb.Empty, error)
	// 批量审核文档
	CheckArticles(context.Context, *CheckArticlesRequest) (*emptypb.Empty, error)
	// 回收站文章列表
	ListRecycleArticle(context.Context, *ListArticleRequest) (*ListArticleReply, error)
	// 恢复回收站文章
	RestoreRecycleArticle(context.Context, *RestoreArticleRequest) (*emptypb.Empty, error)
	// 从回收站删除文章
	DeleteRecycleArticle(context.Context, *DeleteArticleRequest) (*emptypb.Empty, error)
	// 清空回收站
	EmptyRecycleArticle(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// 搜索文章
	SearchArticle(context.Context, *ListArticleRequest) (*SearchArticleReply, error)
	// 相关文章
	GetRelatedArticles(context.Context, *GetArticleRequest) (*ListArticleReply, error)
}

// UnimplementedArticleAPIServer can be embedded to have forward compatible implementations.
type UnimplementedArticleAPIServer struct {
}

func (*UnimplementedArticleAPIServer) CreateArticle(ctx context.Context, req *Article) (*Article, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateArticle not implemented")
}
func (*UnimplementedArticleAPIServer) UpdateArticle(ctx context.Context, req *Article) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateArticle not implemented")
}
func (*UnimplementedArticleAPIServer) DeleteArticle(ctx context.Context, req *DeleteArticleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteArticle not implemented")
}
func (*UnimplementedArticleAPIServer) GetArticle(ctx context.Context, req *GetArticleRequest) (*Article, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArticle not implemented")
}
func (*UnimplementedArticleAPIServer) ListArticle(ctx context.Context, req *ListArticleRequest) (*ListArticleReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArticle not implemented")
}
func (*UnimplementedArticleAPIServer) SetArticlesCategory(ctx context.Context, req *SetArticlesCategoryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetArticlesCategory not implemented")
}
func (*UnimplementedArticleAPIServer) RecommendArticles(ctx context.Context, req *RecommendArticlesRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecommendArticles not implemented")
}
func (*UnimplementedArticleAPIServer) CheckArticles(ctx context.Context, req *CheckArticlesRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckArticles not implemented")
}
func (*UnimplementedArticleAPIServer) ListRecycleArticle(ctx context.Context, req *ListArticleRequest) (*ListArticleReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRecycleArticle not implemented")
}
func (*UnimplementedArticleAPIServer) RestoreRecycleArticle(ctx context.Context, req *RestoreArticleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreRecycleArticle not implemented")
}
func (*UnimplementedArticleAPIServer) DeleteRecycleArticle(ctx context.Context, req *DeleteArticleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRecycleArticle not implemented")
}
func (*UnimplementedArticleAPIServer) EmptyRecycleArticle(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmptyRecycleArticle not implemented")
}
func (*UnimplementedArticleAPIServer) SearchArticle(ctx context.Context, req *ListArticleRequest) (*SearchArticleReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchArticle not implemented")
}
func (*UnimplementedArticleAPIServer) GetRelatedArticles(ctx context.Context, req *GetArticleRequest) (*ListArticleReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRelatedArticles not implemented")
}

func RegisterArticleAPIServer(s *grpc.Server, srv ArticleAPIServer) {
	s.RegisterService(&_ArticleAPI_serviceDesc, srv)
}

func _ArticleAPI_CreateArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Article)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).CreateArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/CreateArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).CreateArticle(ctx, req.(*Article))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_UpdateArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Article)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).UpdateArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/UpdateArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).UpdateArticle(ctx, req.(*Article))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_DeleteArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).DeleteArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/DeleteArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).DeleteArticle(ctx, req.(*DeleteArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_GetArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).GetArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/GetArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).GetArticle(ctx, req.(*GetArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_ListArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).ListArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/ListArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).ListArticle(ctx, req.(*ListArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_SetArticlesCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetArticlesCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).SetArticlesCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/SetArticlesCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).SetArticlesCategory(ctx, req.(*SetArticlesCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_RecommendArticles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecommendArticlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).RecommendArticles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/RecommendArticles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).RecommendArticles(ctx, req.(*RecommendArticlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_CheckArticles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckArticlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).CheckArticles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/CheckArticles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).CheckArticles(ctx, req.(*CheckArticlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_ListRecycleArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).ListRecycleArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/ListRecycleArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).ListRecycleArticle(ctx, req.(*ListArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_RestoreRecycleArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).RestoreRecycleArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/RestoreRecycleArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).RestoreRecycleArticle(ctx, req.(*RestoreArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_DeleteRecycleArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).DeleteRecycleArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/DeleteRecycleArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).DeleteRecycleArticle(ctx, req.(*DeleteArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_EmptyRecycleArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).EmptyRecycleArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/EmptyRecycleArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).EmptyRecycleArticle(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_SearchArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).SearchArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/SearchArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).SearchArticle(ctx, req.(*ListArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleAPI_GetRelatedArticles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleAPIServer).GetRelatedArticles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.v1.ArticleAPI/GetRelatedArticles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleAPIServer).GetRelatedArticles(ctx, req.(*GetArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ArticleAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.ArticleAPI",
	HandlerType: (*ArticleAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateArticle",
			Handler:    _ArticleAPI_CreateArticle_Handler,
		},
		{
			MethodName: "UpdateArticle",
			Handler:    _ArticleAPI_UpdateArticle_Handler,
		},
		{
			MethodName: "DeleteArticle",
			Handler:    _ArticleAPI_DeleteArticle_Handler,
		},
		{
			MethodName: "GetArticle",
			Handler:    _ArticleAPI_GetArticle_Handler,
		},
		{
			MethodName: "ListArticle",
			Handler:    _ArticleAPI_ListArticle_Handler,
		},
		{
			MethodName: "SetArticlesCategory",
			Handler:    _ArticleAPI_SetArticlesCategory_Handler,
		},
		{
			MethodName: "RecommendArticles",
			Handler:    _ArticleAPI_RecommendArticles_Handler,
		},
		{
			MethodName: "CheckArticles",
			Handler:    _ArticleAPI_CheckArticles_Handler,
		},
		{
			MethodName: "ListRecycleArticle",
			Handler:    _ArticleAPI_ListRecycleArticle_Handler,
		},
		{
			MethodName: "RestoreRecycleArticle",
			Handler:    _ArticleAPI_RestoreRecycleArticle_Handler,
		},
		{
			MethodName: "DeleteRecycleArticle",
			Handler:    _ArticleAPI_DeleteRecycleArticle_Handler,
		},
		{
			MethodName: "EmptyRecycleArticle",
			Handler:    _ArticleAPI_EmptyRecycleArticle_Handler,
		},
		{
			MethodName: "SearchArticle",
			Handler:    _ArticleAPI_SearchArticle_Handler,
		},
		{
			MethodName: "GetRelatedArticles",
			Handler:    _ArticleAPI_GetRelatedArticles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/article.proto",
}

func (m *Article) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Article) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Article) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Category) > 0 {
		for iNdEx := len(m.Category) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Category[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArticle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.RejectReason) > 0 {
		i -= len(m.RejectReason)
		copy(dAtA[i:], m.RejectReason)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.RejectReason)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Status != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArticle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.UserId != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.IsRecommend {
		i--
		if m.IsRecommend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.RecommendAt != nil {
		n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.RecommendAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.RecommendAt):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintArticle(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x7a
	}
	if m.CommentCount != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.CommentCount))
		i--
		dAtA[i] = 0x70
	}
	if m.FavoriteCount != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.FavoriteCount))
		i--
		dAtA[i] = 0x68
	}
	if len(m.CategoryId) > 0 {
		dAtA4 := make([]byte, len(m.CategoryId)*10)
		var j3 int
		for _, num1 := range m.CategoryId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintArticle(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x62
	}
	if m.DeletedAt != nil {
		n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.DeletedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.DeletedAt):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintArticle(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x5a
	}
	if m.UpdatedAt != nil {
		n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpdatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintArticle(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x52
	}
	if m.CreatedAt != nil {
		n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CreatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt):])
		if err7 != nil {
			return 0, err7
		}
		i -= n7
		i = encodeVarintArticle(dAtA, i, uint64(n7))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Keywords) > 0 {
		i -= len(m.Keywords)
		copy(dAtA[i:], m.Keywords)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Keywords)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ViewCount != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.ViewCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Identifier) > 0 {
		i -= len(m.Identifier)
		copy(dAtA[i:], m.Identifier)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Identifier)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteArticleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteArticleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteArticleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA9 := make([]byte, len(m.Id)*10)
		var j8 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintArticle(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RestoreArticleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreArticleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreArticleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA11 := make([]byte, len(m.Id)*10)
		var j10 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintArticle(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetArticlesCategoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetArticlesCategoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetArticlesCategoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CategoryId) > 0 {
		dAtA13 := make([]byte, len(m.CategoryId)*10)
		var j12 int
		for _, num1 := range m.CategoryId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintArticle(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ArticleId) > 0 {
		dAtA15 := make([]byte, len(m.ArticleId)*10)
		var j14 int
		for _, num1 := range m.ArticleId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintArticle(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecommendArticlesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendArticlesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecommendArticlesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsRecommend {
		i--
		if m.IsRecommend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ArticleId) > 0 {
		dAtA17 := make([]byte, len(m.ArticleId)*10)
		var j16 int
		for _, num1 := range m.ArticleId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintArticle(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckArticlesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckArticlesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckArticlesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RejeactReason) > 0 {
		i -= len(m.RejeactReason)
		copy(dAtA[i:], m.RejeactReason)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.RejeactReason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ArticleId) > 0 {
		dAtA19 := make([]byte, len(m.ArticleId)*10)
		var j18 int
		for _, num1 := range m.ArticleId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintArticle(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetArticleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetArticleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetArticleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Identifier) > 0 {
		i -= len(m.Identifier)
		copy(dAtA[i:], m.Identifier)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Identifier)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListArticleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListArticleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListArticleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sort) > 0 {
		i -= len(m.Sort)
		copy(dAtA[i:], m.Sort)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Sort)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CreatedAt) > 0 {
		for iNdEx := len(m.CreatedAt) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CreatedAt[iNdEx])
			copy(dAtA[i:], m.CreatedAt[iNdEx])
			i = encodeVarintArticle(dAtA, i, uint64(len(m.CreatedAt[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.UserId) > 0 {
		dAtA21 := make([]byte, len(m.UserId)*10)
		var j20 int
		for _, num1 := range m.UserId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintArticle(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Status) > 0 {
		dAtA23 := make([]byte, len(m.Status)*10)
		var j22 int
		for _, num1 := range m.Status {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintArticle(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IsRecommend) > 0 {
		for iNdEx := len(m.IsRecommend) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.IsRecommend[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintArticle(dAtA, i, uint64(len(m.IsRecommend)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CategoryId) > 0 {
		dAtA25 := make([]byte, len(m.CategoryId)*10)
		var j24 int
		for _, num1 := range m.CategoryId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintArticle(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Order) > 0 {
		i -= len(m.Order)
		copy(dAtA[i:], m.Order)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Order)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Field) > 0 {
		for iNdEx := len(m.Field) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Field[iNdEx])
			copy(dAtA[i:], m.Field[iNdEx])
			i = encodeVarintArticle(dAtA, i, uint64(len(m.Field[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Wd) > 0 {
		i -= len(m.Wd)
		copy(dAtA[i:], m.Wd)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Wd)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Size_ != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Page != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListArticleReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListArticleReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListArticleReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Article) > 0 {
		for iNdEx := len(m.Article) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Article[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArticle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Total != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchArticleReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchArticleReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchArticleReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Article) > 0 {
		for iNdEx := len(m.Article) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Article[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArticle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Spend) > 0 {
		i -= len(m.Spend)
		copy(dAtA[i:], m.Spend)
		i = encodeVarintArticle(dAtA, i, uint64(len(m.Spend)))
		i--
		dAtA[i] = 0x12
	}
	if m.Total != 0 {
		i = encodeVarintArticle(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintArticle(dAtA []byte, offset int, v uint64) int {
	offset -= sovArticle(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Article) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovArticle(uint64(m.Id))
	}
	l = len(m.Identifier)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	if m.ViewCount != 0 {
		n += 1 + sovArticle(uint64(m.ViewCount))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	l = len(m.Keywords)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	if m.CreatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt)
		n += 1 + l + sovArticle(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)
		n += 1 + l + sovArticle(uint64(l))
	}
	if m.DeletedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.DeletedAt)
		n += 1 + l + sovArticle(uint64(l))
	}
	if len(m.CategoryId) > 0 {
		l = 0
		for _, e := range m.CategoryId {
			l += sovArticle(uint64(e))
		}
		n += 1 + sovArticle(uint64(l)) + l
	}
	if m.FavoriteCount != 0 {
		n += 1 + sovArticle(uint64(m.FavoriteCount))
	}
	if m.CommentCount != 0 {
		n += 1 + sovArticle(uint64(m.CommentCount))
	}
	if m.RecommendAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.RecommendAt)
		n += 1 + l + sovArticle(uint64(l))
	}
	if m.IsRecommend {
		n += 3
	}
	if m.UserId != 0 {
		n += 2 + sovArticle(uint64(m.UserId))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 2 + l + sovArticle(uint64(l))
	}
	if m.Status != 0 {
		n += 2 + sovArticle(uint64(m.Status))
	}
	l = len(m.RejectReason)
	if l > 0 {
		n += 2 + l + sovArticle(uint64(l))
	}
	if len(m.Category) > 0 {
		for _, e := range m.Category {
			l = e.Size()
			n += 2 + l + sovArticle(uint64(l))
		}
	}
	return n
}

func (m *DeleteArticleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovArticle(uint64(e))
		}
		n += 1 + sovArticle(uint64(l)) + l
	}
	return n
}

func (m *RestoreArticleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovArticle(uint64(e))
		}
		n += 1 + sovArticle(uint64(l)) + l
	}
	return n
}

func (m *SetArticlesCategoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ArticleId) > 0 {
		l = 0
		for _, e := range m.ArticleId {
			l += sovArticle(uint64(e))
		}
		n += 1 + sovArticle(uint64(l)) + l
	}
	if len(m.CategoryId) > 0 {
		l = 0
		for _, e := range m.CategoryId {
			l += sovArticle(uint64(e))
		}
		n += 1 + sovArticle(uint64(l)) + l
	}
	return n
}

func (m *RecommendArticlesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ArticleId) > 0 {
		l = 0
		for _, e := range m.ArticleId {
			l += sovArticle(uint64(e))
		}
		n += 1 + sovArticle(uint64(l)) + l
	}
	if m.IsRecommend {
		n += 2
	}
	return n
}

func (m *CheckArticlesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ArticleId) > 0 {
		l = 0
		for _, e := range m.ArticleId {
			l += sovArticle(uint64(e))
		}
		n += 1 + sovArticle(uint64(l)) + l
	}
	if m.Status != 0 {
		n += 1 + sovArticle(uint64(m.Status))
	}
	l = len(m.RejeactReason)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	return n
}

func (m *GetArticleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovArticle(uint64(m.Id))
	}
	l = len(m.Identifier)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	return n
}

func (m *ListArticleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovArticle(uint64(m.Page))
	}
	if m.Size_ != 0 {
		n += 1 + sovArticle(uint64(m.Size_))
	}
	l = len(m.Wd)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	if len(m.Field) > 0 {
		for _, s := range m.Field {
			l = len(s)
			n += 1 + l + sovArticle(uint64(l))
		}
	}
	l = len(m.Order)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	if len(m.CategoryId) > 0 {
		l = 0
		for _, e := range m.CategoryId {
			l += sovArticle(uint64(e))
		}
		n += 1 + sovArticle(uint64(l)) + l
	}
	if len(m.IsRecommend) > 0 {
		n += 1 + sovArticle(uint64(len(m.IsRecommend))) + len(m.IsRecommend)*1
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovArticle(uint64(e))
		}
		n += 1 + sovArticle(uint64(l)) + l
	}
	if len(m.UserId) > 0 {
		l = 0
		for _, e := range m.UserId {
			l += sovArticle(uint64(e))
		}
		n += 1 + sovArticle(uint64(l)) + l
	}
	if len(m.CreatedAt) > 0 {
		for _, s := range m.CreatedAt {
			l = len(s)
			n += 1 + l + sovArticle(uint64(l))
		}
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	return n
}

func (m *ListArticleReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovArticle(uint64(m.Total))
	}
	if len(m.Article) > 0 {
		for _, e := range m.Article {
			l = e.Size()
			n += 1 + l + sovArticle(uint64(l))
		}
	}
	return n
}

func (m *SearchArticleReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovArticle(uint64(m.Total))
	}
	l = len(m.Spend)
	if l > 0 {
		n += 1 + l + sovArticle(uint64(l))
	}
	if len(m.Article) > 0 {
		for _, e := range m.Article {
			l = e.Size()
			n += 1 + l + sovArticle(uint64(l))
		}
	}
	return n
}

func sovArticle(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozArticle(x uint64) (n int) {
	return sovArticle(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Article) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Article: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Article: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewCount", wireType)
			}
			m.ViewCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keywords = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.DeletedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CategoryId = append(m.CategoryId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CategoryId) == 0 {
					m.CategoryId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CategoryId = append(m.CategoryId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FavoriteCount", wireType)
			}
			m.FavoriteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FavoriteCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentCount", wireType)
			}
			m.CommentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommentCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecommendAt == nil {
				m.RecommendAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.RecommendAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecommend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecommend = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RejectReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = append(m.Category, &Category{})
			if err := m.Category[len(m.Category)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArticle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArticle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteArticleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteArticleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteArticleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArticle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArticle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreArticleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreArticleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreArticleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArticle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArticle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetArticlesCategoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetArticlesCategoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetArticlesCategoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArticleId = append(m.ArticleId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArticleId) == 0 {
					m.ArticleId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArticleId = append(m.ArticleId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArticleId", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CategoryId = append(m.CategoryId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CategoryId) == 0 {
					m.CategoryId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CategoryId = append(m.CategoryId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArticle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArticle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendArticlesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendArticlesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendArticlesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArticleId = append(m.ArticleId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArticleId) == 0 {
					m.ArticleId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArticleId = append(m.ArticleId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArticleId", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecommend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecommend = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipArticle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArticle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckArticlesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckArticlesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckArticlesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArticleId = append(m.ArticleId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArticleId) == 0 {
					m.ArticleId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArticleId = append(m.ArticleId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArticleId", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejeactReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RejeactReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArticle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArticle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetArticleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetArticleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetArticleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArticle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArticle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListArticleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListArticleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListArticleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = append(m.Field, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CategoryId = append(m.CategoryId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CategoryId) == 0 {
					m.CategoryId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CategoryId = append(m.CategoryId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IsRecommend = append(m.IsRecommend, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.IsRecommend) == 0 {
					m.IsRecommend = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IsRecommend = append(m.IsRecommend, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecommend", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserId = append(m.UserId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArticle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArticle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArticle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserId) == 0 {
					m.UserId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArticle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserId = append(m.UserId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = append(m.CreatedAt, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArticle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArticle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListArticleReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListArticleReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListArticleReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Article", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Article = append(m.Article, &Article{})
			if err := m.Article[len(m.Article)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArticle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArticle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchArticleReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchArticleReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchArticleReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spend = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Article", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArticle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArticle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Article = append(m.Article, &Article{})
			if err := m.Article[len(m.Article)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArticle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArticle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipArticle(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowArticle
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArticle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthArticle
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupArticle
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthArticle
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthArticle        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowArticle          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupArticle = fmt.Errorf("proto: unexpected end of group")
)
